<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-11T07:15:23.522Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>参与开源项目记录（持续更新中...）</title>
    <link href="http://example.com/2024/06/11/%E5%8F%82%E4%B8%8E%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD-%EF%BC%89/"/>
    <id>http://example.com/2024/06/11/%E5%8F%82%E4%B8%8E%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD-%EF%BC%89/</id>
    <published>2024-06-11T06:51:30.000Z</published>
    <updated>2024-06-11T07:15:23.522Z</updated>
    
    <content type="html"><![CDATA[<p>记录自己作为reviewer参与causaldmir-package的开发工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录自己作为reviewer参与causaldmir-package的开发工作。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>在VScode上管理自己hexo博客（解决VScode编辑文件权限问题）</title>
    <link href="http://example.com/2024/06/11/%E5%9C%A8VScode%E4%B8%8A%E7%AE%A1%E7%90%86%E8%87%AA%E5%B7%B1hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2024/06/11/%E5%9C%A8VScode%E4%B8%8A%E7%AE%A1%E7%90%86%E8%87%AA%E5%B7%B1hexo%E5%8D%9A%E5%AE%A2/</id>
    <published>2024-06-11T06:24:35.000Z</published>
    <updated>2024-06-11T07:18:04.056Z</updated>
    
    <content type="html"><![CDATA[<p>我的hexo博客是在Ubuntu上创建的虚拟机里的blog目录里管理的，包括文章的更新，修改以及推送到远端都是在Linux的终端操作的，但是每次在虚拟机里的终端操作都很麻烦，尤其是用vim编辑器编辑文章的时候，虚拟机的终端的页面调整光标位置要辅以快捷键，很不方便，如果是VScode连接远程虚拟机，在VScode上面编辑文章就可以手动调整光标位置，而且目录结构清晰，查看blog里面的其他文件也很方便，总之推荐使用VScode来管理自己的博客~</p><p>不过第一次使用VScode编辑文件会出现一个问题：编辑文件的权限问题，如图：<br><img src="/assets/VScode%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98.png" alt="问题图"></p><p>解决问题的办法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R miumiujiang:miumiujiang /home/miumiujiang/blog/sourece/_posts/</span><br></pre></td></tr></table></figure><p>将miumiujiang替换成自己的虚拟机用户名即可，简单来说就是更改了&#x2F;home&#x2F;miumiujiang&#x2F;blog&#x2F;sourece&#x2F;_posts&#x2F;的权限。本来是root才有权限读写该文件，但是更改权限后miumiujiang也可以读写文件：<br><img src="/assets/%E6%9D%83%E9%99%90%E5%9B%BE.png" alt="权限图"><br>可以用ls命令检查一下文件所在目录的权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /home/miumiujiang/blog/source/_posts</span><br></pre></td></tr></table></figure><p>改权限后：<br><img src="/assets/%E6%9D%83%E9%99%90%E5%9B%BE2.png" alt="权限图"></p><p>这样就可以直接在VScode编辑页面编辑blog里的文件啦~<br><img src="/assets/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.png" alt="问题解决"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的hexo博客是在Ubuntu上创建的虚拟机里的blog目录里管理的，包括文章的更新，修改以及推送到远端都是在Linux的终端操作的，但是每次在虚拟机里的终端操作都很麻烦，尤其是用vim编辑器编辑文章的时候，虚拟机的终端的页面调整光标位置要辅以快捷键，很不方便，如果是VS</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>关于git的踩坑记录（解决SSH连接问题）</title>
    <link href="http://example.com/2024/06/11/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2024/06/11/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2024-06-11T06:18:17.000Z</published>
    <updated>2024-06-11T10:51:21.911Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下git pull&#x2F;push时遇到问题以及解决方法。</p><p>在我尝试在一个开源项目的某个分支zhiyi（该分支在远程仓库upstream中）上新开一个自己的分支qianh进行工作时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout upstream/zhiyi <span class="comment"># 切换到upstream远程仓库里的zhiyi分支</span></span><br><span class="line">git pull upstream zhiyi <span class="comment">#将upstream仓库里的最新信息拉取到zhiyi分支</span></span><br><span class="line">git checkout -b qianh <span class="comment">#在zhiyi分支上新建一个本地分支qianh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这样就成功地在 zhiyi 分支的基础上创建了一个新的分支 qianh，并且qianh分支与zhiyi 分支上的信息同步</span></span><br></pre></td></tr></table></figure><p>然而在，拉取upstream的代码时出现以下问题：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="literal">-T</span> git@github.com</span><br></pre></td></tr></table></figure><p>然后出现这个报错：<strong><a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#x2e;&#99;&#111;&#109;">&#103;&#105;&#x74;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#x2e;&#99;&#111;&#109;</a>: Permission denied (publickey)<strong>，这表示</strong>ssh连接权限被拒绝</strong>，解决问题的步骤如下：<br>问题的本质是新建分支qianh与GitHub连接的问题，将ssh连接问题解决即可。</p><h2 id="1、在本地生成ssh密钥"><a href="#1、在本地生成ssh密钥" class="headerlink" title="1、在本地生成ssh密钥"></a>1、在本地生成ssh密钥</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa <span class="literal">-b</span> <span class="number">4096</span> <span class="literal">-C</span> <span class="string">&quot;miumiujiang12138@gmail.com&quot;</span> <span class="comment"># 生成SSH密钥，包括公钥与私钥，这一步是在VScode的终端上运行</span></span><br></pre></td></tr></table></figure><p>生成密钥后，查看公钥的内容，文件后缀名为.pub，我自己的公钥文件名为HQoooo0000.pub，cat一下，然后复制HQoooo0000.pub里的内容，去GitHub网页–设置–SSH与GPG公钥中新建SSH公钥，将复制的内容粘贴到对应的面板内，如图：<br><img src="/assets/SSH%E5%AF%86%E9%92%A5%E6%B7%BB%E5%8A%A0.png" alt="SSH添加密钥"></p><h2 id="2、启动SSH代理并将私钥添加至SSH代理"><a href="#2、启动SSH代理并将私钥添加至SSH代理" class="headerlink" title="2、启动SSH代理并将私钥添加至SSH代理"></a>2、启动SSH代理并将私钥添加至SSH代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> $(ssh-agent -s) <span class="comment"># 启动SSH代理，在git bash上运行</span></span><br><span class="line">ssh-add /d/GitSrc/causal-dmir/HQoooo0000  <span class="comment"># 将私钥添加到ssh代理，HQoooo0000是我的私钥文件名，在git bash上运行</span></span><br></pre></td></tr></table></figure><h2 id="3、确认本地SSH配置"><a href="#3、确认本地SSH配置" class="headerlink" title="3、确认本地SSH配置"></a>3、确认本地SSH配置</h2><p>将私钥添加至SSH代理之后，需要在你本地的SSH配置（ssh配置文件在user&#x2F;.ssh&#x2F;config）里添加你的私钥位置：<br><img src="/assets/SSH%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="SSH配置文件位置"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  User git</span><br><span class="line">  IdentityFile /d/GitSrc/causal-dmir/HQoooo0000</span><br></pre></td></tr></table></figure><p>配置好的.ssh&#x2F;config文件如图：<br><img src="/assets/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%9A%84config.png" alt="config文件"></p><h2 id="4、确保在VSCode的PowerShell终端中也能正确使用SSH代理"><a href="#4、确保在VSCode的PowerShell终端中也能正确使用SSH代理" class="headerlink" title="4、确保在VSCode的PowerShell终端中也能正确使用SSH代理"></a>4、确保在VSCode的PowerShell终端中也能正确使用SSH代理</h2><p>上面三步完成后，测试一下git能否正确连接SSH</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com <span class="comment"># git bash中测试</span></span><br></pre></td></tr></table></figure><p>我的git显示：Hi miumiujiang! You’ve successfully authenticated, but GitHub does not provide shell access.<br>说明git这里已经可以通过SSH连接github了，但是VScode的终端仍然无法正确连接SSH。</p><ul><li>在git Bash中获取SSH代理的环境变量<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$SSH_AUTH_SOCK</span> <span class="comment"># git bash中运行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SSH_AGENT_PID</span></span><br></pre></td></tr></table></figure></li><li>在VSCode的PowerShell终端中设置这些环境变量<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:SSH_AUTH_SOCK</span>=<span class="string">&quot;/tmp/ssh-08McmaEDsQeY/agent.1395&quot;</span> <span class="comment"># powershell中运行</span></span><br><span class="line"><span class="variable">$env:SSH_AGENT_PID</span>=<span class="string">&quot;1396&quot;</span></span><br></pre></td></tr></table></figure>测试一下powershell能否正确连接SSH：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="literal">-T</span> git@github.com <span class="comment"># powershell中测试</span></span><br></pre></td></tr></table></figure>我的powershell终端显示：Hi miumiujiang! You’ve successfully authenticated, but GitHub does not provide shell access.<br>说明powershell这里已经可以通过SSH连接github了。<br>接下来就可以顺利进行git pull&#x2F;push操作啦~</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下git pull&amp;#x2F;push时遇到问题以及解决方法。&lt;/p&gt;
&lt;p&gt;在我尝试在一个开源项目的某个分支zhiyi（该分支在远程仓库upstream中）上新开一个自己的分支qianh进行工作时：&lt;/p&gt;
&lt;figure class=&quot;highlight bash</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>关于用生成模型（CRBM）对阿尔兹海默症患者病程进行个性化预测的文章汇报</title>
    <link href="http://example.com/2024/06/05/%E4%BA%8E/"/>
    <id>http://example.com/2024/06/05/%E4%BA%8E/</id>
    <published>2024-06-05T07:11:28.000Z</published>
    <updated>2024-06-05T10:04:09.211Z</updated>
    
    <content type="html"><![CDATA[<p>最近读了两篇关于用生成模型<strong>CRBM</strong>（条件限制波尔兹曼机），简单做一些归纳总结。<br>首先，这两篇文章是同一作者所著，第一篇文章<strong>关于机器学习在阿尔兹海默症上的应用</strong>讨论了CRBM在生成阿尔兹海默症（以下简称AD）患者的医疗记录以及预测AD患者病程轨迹这两个方面的优越性能。第二篇文章<strong>使用数字孪生模拟AD患者和MIC患者的病程进展</strong>是在第一篇文章提出的CRBM模型基础上，拓展了数据集，并解决了拓展数据集之后出现的问题，使模型能够精准预测AD或者MIC患者的病程进展。</p><h1 id="文章1要解决的问题"><a href="#文章1要解决的问题" class="headerlink" title="文章1要解决的问题"></a>文章1要解决的问题</h1><h2 id="生成虚拟的AD患者医疗记录"><a href="#生成虚拟的AD患者医疗记录" class="headerlink" title="生成虚拟的AD患者医疗记录"></a>生成虚拟的AD患者医疗记录</h2><p>这种生成数据的方法可以帮助专业人员优化临床试验设计、降低试验成本。</p><h2 id="预测AD患者的病程进展-轨迹"><a href="#预测AD患者的病程进展-轨迹" class="headerlink" title="预测AD患者的病程进展&#x2F;轨迹"></a>预测AD患者的病程进展&#x2F;轨迹</h2><p>可以为患者提供个性化的医疗方案，有助于智慧医疗的发展。</p><h1 id="解决问题的价值和意义"><a href="#解决问题的价值和意义" class="headerlink" title="解决问题的价值和意义"></a>解决问题的价值和意义</h1><ul><li>临床数据通常包括不同类型的数据，如连续型、离散型、布尔型、定序型等，CRBM可以轻松地对于多类型变量数据建模，网络中不同的可见节点可对于不同的数据类型同时进行建模，这为处理复杂的临床数据提供了一种强大的工具。</li><li>CRBM允许数据的条件生成和采样，为时间序列数据建模提供了重要条件。</li><li>患者病程进展本身是一个随机过程，因此要求模型可以捕捉到数据中的随机性，而CRBM所提供的mcmc采样自然的捕捉到了数据中的随机性，极大地提高了患者临床医疗记录进展预测的精确性和可靠性。</li></ul><h1 id="怎么解决该问题"><a href="#怎么解决该问题" class="headerlink" title="怎么解决该问题?"></a>怎么解决该问题?</h1><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>对于任务一，固定某个时间点，将所有患者（1909名）患者的医疗记录作为输入，模型训练好后会学到在时间点t下的联合概率分布P{<strong>X</strong>}，从而生成该时间点下的虚拟患者医疗记录。<br>对于任务二，先将某个患者医疗记录上的所有临床变量分为动态变量和静态变量两部分，其中静态变量是指与时间变化无关的一些背景变量，如患者性别、种族等；动态变量是会随时间变化的变量如ADAS认知分数、一些临床上的理化指标等。将患者i在t0时刻和t1时刻的动态变量与静态变量的数据组成一个三元组Vi&#x3D;{<strong>X</strong>t1(dynamic),<strong>X</strong>t0(dynamic),<strong>X</strong>(static)}，总共有1909名患者，将这些处理好的三元组作为输入，模型训练好后会学到P{<strong>X</strong>t1|<strong>X</strong>t0}这样的概率分布，这样迭代的学习P{<strong>X</strong>t2|<strong>X</strong>t1}、P{<strong>X</strong>t3|<strong>X</strong>t2}直到P{<strong>X</strong>tn|<strong>X</strong>tn-1},就可以根据学习到的概率分布来生成数据并采样作为预测结果了。</p><h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>模型训练方法采用对比散度法。先将网络中的可见单元状态初始化然后根据随机状态方程计算与之连接的隐含单元状态，迭代的计算下去，根据E2更新权重，直至网络稳定（能量函数的值达到最小），表示模型已经训练好或者说模型已经学习到了数据中的概率分布。</p><h2 id="mcmc采样"><a href="#mcmc采样" class="headerlink" title="mcmc采样"></a>mcmc采样</h2><p>模型训练好之后，网络节点间的权重和偏置已经确定，模型可根据这个权重和偏置来生成数据并采样作为最终的生成数据。</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h1 id="文章2要解决的问题"><a href="#文章2要解决的问题" class="headerlink" title="文章2要解决的问题"></a>文章2要解决的问题</h1><p>这一篇文章是对上一篇文章的拓展和改进，对数据进行了拓展，上一篇文章的患者医疗记录里有44个临床变量，涉及1909名患者，这一篇文章整合了64个临床变量，共涉及6919名患者。拓展数据集后带来的问题是有些动态变量记录的时间频率不一致，比如ADAS认知分数必须三个月随访记录一次，而CDR只能每六个月随访记录一次，还有一些MMSE类的变量每三个月和每隔六个月都要记录一次。每隔三个月记录一次的变量我称之为三个月变量，这些变量的时效是三个月；每隔六个月记录一次的变量我称之为六个月变量，这些变量的时效是6个月；而每三个月和每六个月都要随访记录一次的变量我称之为共享变量，这些变量的时效可以是三个月，也可以是六个月。<br>这带来的问题是：如果只采用一个训练好的以三个月为时间梯度的CRBM模型，那么对于六个月变量的数据由于其时效为六个月，这部分数据无法预测；如果只采用一个训练好的以六个月为时间梯度的CRBM模型，对于三个月变量来说，预测的数据不够精确。那么怎么改进模型使其对于所有变量都达到一个良好的预测效果呢？</p><h1 id="怎么解决该问题？"><a href="#怎么解决该问题？" class="headerlink" title="怎么解决该问题？"></a>怎么解决该问题？</h1><p>答案是训练两个CRBM模型结合使用，一个是3mon-CRBM，另一个是6mon-CRBM，将三个月变量以及共享变量作为输入，放进3mon-CRBM中训练，这样三个月变量以及共享变量的数据就可以在3mon-CRBM中采样生成；然后将共享变量在六个月梯度这里，和六个月变量的基线数据放到6mon-CRBM中训练，这样模型就可以学到P{<strong>X</strong>6mon|<strong>X</strong>both 3mon and 6mon},从而在该分布中生成数据并采样。这样就可以确保在拓展的患者医疗记录中的所有变量都可以得到精准预测，提高了模型的性能。</p><h1 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近读了两篇关于用生成模型&lt;strong&gt;CRBM&lt;/strong&gt;（条件限制波尔兹曼机），简单做一些归纳总结。&lt;br&gt;首先，这两篇文章是同一作者所著，第一篇文章&lt;strong&gt;关于机器学习在阿尔兹海默症上的应用&lt;/strong&gt;讨论了CRBM在生成阿尔兹海默症（以下简称A</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>因果推理导论学习1</title>
    <link href="http://example.com/2024/06/04/%E5%9B%A0%E6%9E%9C%E6%8E%A8%E7%90%86%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A01/"/>
    <id>http://example.com/2024/06/04/%E5%9B%A0%E6%9E%9C%E6%8E%A8%E7%90%86%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A01/</id>
    <published>2024-06-04T06:07:51.000Z</published>
    <updated>2024-06-06T15:10:40.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="因果≠相关"><a href="#因果≠相关" class="headerlink" title="因果≠相关"></a>因果≠相关</h2><ul><li>相关关系：相关关系是指两个变量在概率分布上的相似程度，相关关系本身不用于描述因果关系这种决定性指标。</li><li>因果关系：与相关关系对比，因果关系区分了原因变量和结果变量。借助自然科学研究的思路来定义因果关系，即<strong>假设存在两个目标变量X和Y，在控制能影响Y的一切其他变量保持不变的同时，改变X的状态，观察Y是否随之发生改变。如果Y发生了改变，那么称X是Y的原因，Y是X的结果，X与Y之间具有因果关系</strong>。</li></ul><h3 id="是什么导致因果≠相关呢？"><a href="#是什么导致因果≠相关呢？" class="headerlink" title="是什么导致因果≠相关呢？"></a>是什么导致因果≠相关呢？</h3><p>导致因果≠相关的因素主要有两种：混杂和选择性偏差。</p><ul><li>混杂是指同时影响策略选择和结果变量的变量，混杂的存在会导致评估策略变量对于结果的变量的影响出现偏差。</li><li>选择性偏差也叫对撞偏差，指由于选择<strong>对撞子</strong>作为划分群体的变量导致不同的群体之间出现了虚假的因果效应。</li></ul><h4 id="注：对撞子是指受多个因变量的共同结果。"><a href="#注：对撞子是指受多个因变量的共同结果。" class="headerlink" title="注：对撞子是指受多个因变量的共同结果。"></a>注：对撞子是指受多个因变量的共同结果。</h4><h2 id="随机对照试验"><a href="#随机对照试验" class="headerlink" title="随机对照试验"></a>随机对照试验</h2><p>随机对照试验的<strong>同质群体策略随机分配</strong>的核心理念是评估因果效应的黄金准则。</p><h3 id="同质群体"><a href="#同质群体" class="headerlink" title="同质群体"></a>同质群体</h3><p>同质群体意味着在试验开始时，各组受试者在重要特征（如年龄、性别、健康状况等）上尽可能一致。这样可以减少混杂变量的影响，使得观察到的效果更可能是由于干预措施本身，而不是由于其他潜在的差异。</p><h3 id="策略随机分配"><a href="#策略随机分配" class="headerlink" title="策略随机分配"></a>策略随机分配</h3><p>策略随机分配中的“策略”指的是在随机对照试验（RCT）中，研究人员将受试者随机分配到不同的试验组（如干预组和对照组）。这个过程确保了每个受试者被分配到任意一组的概率是相等的，从而消除了选择性偏差和其他系统性差异。<br>随机对照试验的流程如下：<br><img src="/assets/%E9%9A%8F%E6%9C%BA%E5%AF%B9%E7%85%A7%E8%AF%95%E9%AA%8C.png" alt="随机对照试验流程"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;因果≠相关&quot;&gt;&lt;a href=&quot;#因果≠相关&quot; class=&quot;headerlink&quot; title=&quot;因果≠相关&quot;&gt;&lt;/a&gt;因果≠相关&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;相关关系：相关关系是指两个变量在概率分布上的相似程度，相关关系本身不用于描述因果关系这种决定性指标。&lt;/</summary>
      
    
    
    
    
    <category term="Causal-learning" scheme="http://example.com/tags/Causal-learning/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch深度学习小项目学习总结</title>
    <link href="http://example.com/2024/03/26/Pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B0%8F%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2024/03/26/Pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B0%8F%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2024-03-26T01:24:57.000Z</published>
    <updated>2024-03-27T08:25:23.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单车预测器"><a href="#单车预测器" class="headerlink" title="单车预测器"></a>单车预测器</h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>共享单车在给人们带来便利的同时，也存在一个麻烦的问题：单车的分布很不均匀。比如在早高峰的时候，一些地铁口往往聚集着大量的单车，而到了晚高峰却很难找到一辆单车了，这就给需要使用共享单车的人造成了不便。那么如何解决共享单车分布不均匀的问题呢？目前的方式是，共享单车公司会雇一些工人来搬运单车，把它们运送到需要单车的区域。但问题是应该运多少单车？什么时候运？运到什么地方呢？这就需要准确地知道共享单车在整个城市不同地点的数量分布情况，而且需要提前做出安排，因为工人运送单车还有一定的延迟性。这对于共享单车公司来说是一个非常严峻的挑战。为了更加科学有效地解决这个问题，我们需要构造一个共享单车预测器，用来预测某一时间、某一停放区域的单车数量，供共享单车公司参考，以实现对单车的合理投放。<br>要解决的问题就是，<strong>能否根据历史数据预测接下来一段时间该地区单车数量的走势呢</strong>？</p><h3 id="使用的神经网络"><a href="#使用的神经网络" class="headerlink" title="使用的神经网络"></a>使用的神经网络</h3><p>使用<strong>前馈神经网络</strong>，前馈神经网络是目前应用范围最大的一种神经网络，它的架构有三层，包括输入层，隐含层以及输出层。其中隐含层包括多层，这就构成了所谓深度学习网络。</p><p>前馈神经的运行过程，该过程包括两部分，前馈神经网络的预测过程和反馈的学习过程。</p><p>前馈预测过程，就是数据输入进输入层，然后经过激活函数的计算，将各个边的权重输入进隐含层，隐含层将各个边的权重进行加权求和得到下一个隐含层的输入，再由下一隐含层的激活函数重复以上操作，最终得到输出层的输出。神经网络在训练阶段将会调节每条连边上的权重w的数值。</p><p>反馈学习过程中，每个输出神经元会首先计算出它的预测误差，然后将这个误差沿着网络的所有连边进行反向传播，得到每个隐含层节点的误差，最后根据每条连边所连通的两个节点的误差计算连边上的权重更新量，从而完成网络的学习与调整。</p><h3 id="如何训练该神经网络"><a href="#如何训练该神经网络" class="headerlink" title="如何训练该神经网络"></a>如何训练该神经网络</h3><ul><li>激活函数的选取：</li></ul><p>选择sigmoid函数，该函数包含了exp（指数函数），可以映射输入层到隐含层或者隐含层到输出层的非线性关系。因为单车数量的分布是受多个因素影响的，比如当天的时段、天气以及是否是节假日等因素。因此选择sigmiod函数来描述层与层之间的一个非线性映射。</p><ul><li>定义损失函数：</li></ul><p>要想完成神经网络的训练，首先要给这个神经网络定义一个损失函数，用来衡量网络在现有的参数组合下输出的表现。这里选择总误差函数作为损失函数L，对于所有的数据样本，神经网络预测的单车数量与实际数据中单车数量之差的平方和的均值。我们需要让这个L的值最小化，从而使模型的性能最优。神经网络要学习的就是神经元之间连边上的权重及偏置，学习的目的是得到一组能够使总误差最小的参数值组合。采用梯度下降算法（这里的梯度是指网络中每条边的权重对于损失函数L的偏导数），每次迭代都使梯度的数值减小，通过反向传播算法来调节网络的权重或者偏置（即网络可以学习到的参数），继续迭代调参，直至求得L的极小值。</p><ul><li>用了几个epoch？学习率是多少？</li></ul><p>进行了100000步迭代周期，学习率是0.001,也就是说每100步，神经网络就会调整一次参数并且清空梯度，再进入下一轮迭代。</p><h3 id="遇到的问题以及解决方式"><a href="#遇到的问题以及解决方式" class="headerlink" title="遇到的问题以及解决方式"></a>遇到的问题以及解决方式</h3><ol><li><strong>模型拟合效果不佳</strong>：</li></ol><p>预测曲线在第一个波峰比较好地拟合了数据，但是在此后，它却与真实数据相差甚远。原因是单车在某一区域的数量x的取值范围是[1-50]，而神经网络的参数（网络的权重或者偏置）的取值范围是[-1-1]的正态分布随机数，那么输入层到隐含层节点的数值范围就成了的-50~50，要想将sigmoid函数的多个峰值调节到我们期望的位置，需要耗费很多计算时间。</p><p><strong>解决办法</strong>：将输入数据的范围做归一化处理，也就是让x的输入数值范围为0-1。因为数据中x的范围是1-50，所以，我们只需要将每一个数值都除以50就可以了，事实证明，预测曲线的拟合效果更好了。</p><ol start="2"><li><strong>出现过拟合现象</strong>：</li></ol><p>模型预测与实际数据竟然完全对不上，说明出现了过拟合。所谓过拟合(overfitting)现象，是指模型可以在训练数据上进行非常好的预测，但在全新的测试数据上表现不佳。原因就在于我选择了错误的特征变量：我们尝试用数据的下标(1, 2, 3, …)或者它的归一化(0.1, 0.2, …)来对y进行预测。然而曲线的波动模式（也就是单车的使用数量）显然并不依赖于下标，而是依赖于诸如天气、风速、星期几和是否是节假日等因素。</p><p><strong>解决办法</strong>：将类型变量单独处理，用独热编码来表示类型变量。。在类型变量中，数字的大小实际上没有任何意义。比如数字5比数字1大，但这并不代表周五会比周一更特殊。除此之外，不同的数值变量的变化范围也不一样。如果直接把它们混合在一起，势必会造成不必要的麻烦。pandas包可以很好的解决将类型变量转化为独热编码的问题。</p><p>数值变量的问题在于每个变量的变化范围都不一样，单位也不一样，因此不同的变量不能进行比较。我们采取的解决方法是对这种变量进行标准化处理，也就是用变量的均值和标准差来对该变量做标准化，从而把特征数值的平均值变为0，标准差变为1。</p><p>将数据进行正确的处理之后，过拟合现象消失了，训练好的模型在测试集上也有较好的表现。</p><h2 id="文本情绪识别器"><a href="#文本情绪识别器" class="headerlink" title="文本情绪识别器"></a>文本情绪识别器</h2><h3 id="问题背景-1"><a href="#问题背景-1" class="headerlink" title="问题背景"></a>问题背景</h3><p>解决的问题是如何识别一段文字中的情绪，从而判断这句话是称赞还是抱怨。根据文本的词袋模型来对文本进行建模，然后利用一个神经网络来对文本进行分类。我使用了从京东商城的大量商品评论中抓取的文本及分类标签来训练神经网络。</p><h3 id="使用的神经网络-1"><a href="#使用的神经网络-1" class="headerlink" title="使用的神经网络"></a>使用的神经网络</h3><p>使用的还是<strong>前馈神经网络</strong>，但是这次要解决的问题是分类问题而不是预测问题。与预测神经网络的输出层不同，分类神经网络的输出层虽然也是一个实数，但它的取值范围是 (0, 1)区间中的一个实数，而且要求输出单元的所有输出值之和为1。我们要从所有的输出中选择一个数值最大的进行输出，它所对应的神经元编号就是神经网络给出的最后类别。可以认为所有输出单元的表示的是特征变量分属于某种类别的概率，我们取所有输出神经元中数值最大（概率最大）的作为特征变量最后的类别。构建的简单神经网络分类器是一个3层的神经网络，第一层由7135个输入节点构成，中间层由10个节点构成，最后一层由两个节点的输出构成，这可以帮助我们判断评论中的情绪，只区分好评和差评。</p><h3 id="如何训练该神经网络-1"><a href="#如何训练该神经网络-1" class="headerlink" title="如何训练该神经网络"></a>如何训练该神经网络</h3><ul><li>文本数据向量化：</li></ul><p>输入的文本为不等长的符号序列，而神经网络的输入层通常具有固定的单元数，应该如何把不等长的文本输入到神经网络中呢？使用词袋模型，它是一种简单而有效的对文本进行向量化表示的方法。简单来讲，词袋模型就是将一句话中的所有单词都放进一个袋子（单词表）里，而忽略语法、语义，甚至单词之间的顺序等信息。我们只关心每一个单词的数量，然后根据数量建立对句子进行表征的向量。</p><p>首先我们需要把下载好的语料，进行分词，建立一个单词表（可以将单词表作为一个容器，里面存储键值对，其中键是分好的单词，值是每一个单词出现的频率），然后，根据这个单词表，按顺序统计出每一个单词在每一个句子中出现的次数，构成一个向量，这样一来，每个句子的向量表示就具有了相同的长度，也就很容易让神经网络来处理了。为了让计算更精确，我们还可以将每个向量都归一化，这样神经网络训练的速度就更快结果也更加精确。通过调用“结巴”分词包来对原始文本进行分词。我们只需要调用jieba.lcut(x)就可以将x中的字符分成若干个单词，并存储在一个列表中。这里我下载的语料分成了7135个词，将每一条评价都向量化为7135维的向量。</p><ul><li>划分数据集</li></ul><p>然后，将所有数据分成训练集、校验集和测试集，其中训练集占大多数，校验集和测试集占比较少。通常情况下，这3种数据集的大小比例大概是10:1:1，为什么要多出一个校验集呢？这是为了检验模型是否会产生过拟合现象。过拟合现象，通俗地说，就是指模型过于“死记硬背”，而无法将学到的知识活学活用，举一反三。在神经网络中，这种“死记硬背”就体现为网络可以很好地拟合训练集数据，却无法泛化到测试集。于是，我们需要减少模型的超参数或者提高数据量，从而提升模型的泛化能力。那么，怎么知道模型调整到什么时候为止呢？这就需要用到校验集了。首先，在训练模型的时候，是不使用校验集的。其次，在一组超参数下，当我们训练好模型之后，可以利用校验集的数据来测试模型的表现，如果误差与训练数据同样低或差不多，就说明模型的泛化能力很强，否则就说明出现了过拟合的现象。我们可以通过改变超参数、增加dropout层或者增加训练数据等方式来避免过拟合。</p><ul><li>激活函数的选取</li></ul><p>从输入层到隐含层选取Linear函数作为一个线性映射；中间隐含层到隐含层选取relu函数作为一个非线性映射，最后的隐含层到输出层选取神经网络中经常用到的softmax函数（归一化指数函数），softmax函数的输出函数图像与上一章介绍的sigmoid函数非常相似，因此softmax函数也起到了非线性映射的作用。同时，由于softmax函数包含了指数函数exp，所以它的输出值必然大于0；又因为softmax函数的每一项都要除以一个归一化因子，所以这种形式自然保证了输出值之和必然等于1。</p><ul><li>定义损失函数</li></ul><p>采用<strong>交叉熵形式的损失函数</strong>，交叉熵函数反映的是特征变量输入到输出层神经元的概率分布与标准答案中相关类别的概率分布之间的差异程度。这两个分布之间的差异程度在信息论中叫做交叉熵。计算出损失函数的值，该值存储在loss中，调用loss.backward()函数就可以进行反向传播算法了。</p><ul><li>优化器optimizer</li></ul><p>优化器采用SDG算法（随机梯度下降算法），不仅可以调节神经网络中的参数还能自动调节学习率。</p><ul><li>epoch数量</li></ul><p>循环10个epoch，每隔3000步在校验集上运行一次，得到临时结果。调用rightness()函数计算准确率。</p><h3 id="遇到的问题以及解决方法"><a href="#遇到的问题以及解决方法" class="headerlink" title="遇到的问题以及解决方法"></a>遇到的问题以及解决方法</h3><p>最终的运行结果，模型在校验集上面的准确率达到92%，在测试集上面的准确率达到了90%，说明模型可以比较准确地识别京东商品评论所含情绪。当然，这仅能说明我们的神经网络针对网上购物评论效果很好，它不一定能够判断出一般的自然语言中的情绪。这是因为神经网络的工作严重依赖于训练数据。如果换一组不同风格的新数据，它的准确率就会有所下降。</p><p><strong>解决办法</strong>：</p><ol><li>使用预训练模型：如Word2Vec、GloVe或BERT，这些模型在大规模语料库上预训练，已经学习到了丰富的语言特征，可以帮助改善模型对于未见过数据的处理能力。</li><li>采用更高级的模型结构，如循环神经网络（RNN）或长短期记忆网络（LSTM），这些模型能够处理文本中的序列信息，更好地理解语言的上下文关系。</li></ol><h2 id="基于VGG和迁移学习的图像风格迁移器"><a href="#基于VGG和迁移学习的图像风格迁移器" class="headerlink" title="基于VGG和迁移学习的图像风格迁移器"></a>基于VGG和迁移学习的图像风格迁移器</h2><h3 id="问题背景-2"><a href="#问题背景-2" class="headerlink" title="问题背景"></a>问题背景</h3><p>首先我们就来看看什么是风格迁移。要了解风格迁移的含义，首先要明白它解决的问题是什么：指定一幅输入图像作为基础图像，也称内容图像，同时指定另一幅或多幅图像作为目标图像风格，算法在保证内容图像大体结构的同时，获得了目标图像风格，使最终输出的合成图像呈现出输入图像内容和目标风格的完美结合，这就是风格迁移。<br>如图所示：<br><img src="/assets/%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB.png" alt="将梵高的星空图风格迁移至风景照"></p><h3 id="神经网络实现风格迁移的基本思想"><a href="#神经网络实现风格迁移的基本思想" class="headerlink" title="神经网络实现风格迁移的基本思想"></a>神经网络实现风格迁移的基本思想</h3><p>要生成一张在内容上与原始图像相似而在风格上与目标风格图像相似的图，关键是要解决如何刻画这种相似性的问题。</p><p>首先，以内容相似性为例，我们显然不能按照逐个像素点来计算原始图像和生成图像的误差。这是因为这里的内容相似性并不是指微观细节一模一样，而是指在宏观视觉感受上的相似。这种宏观视觉感受恰恰可以被卷积神经网络的高层特征图所捕获，因为层级越高的卷积神经网络越能反映输入图像在整体尺度上的特征。这样我们也许可以通过比较高层特征图的误差来捕获内容上的差异。具体来讲，我们可以将原始图像和目标图像同时输入相同的卷积神经网络，并考察该网络在高层的特征图输出，然后逐个像素地计算这两张特征图的误差，就反映了图像之间在整体尺度下的内容相似度。</p><p>其次，看看图像风格相似度的计算。在对风格迁移历史的回顾中，我们看到物体的纹理可以看作一种图像风格。而纹理的本质就是某种图像模式在空间中的不断重复和平铺。熟悉卷积神经网络的话，可以发现卷积运算恰好能够捕捉这种空间中的重复模式。因此，<strong>如果一张图像具有某种风格，它就会在不同的卷积核形成的特征图上反映出来</strong>。所以，一幅画作的风格就可以被任意两个特征图的相关性所刻画，这便是Gram矩阵的由来。</p><p>Gram矩阵的由来：对于某层卷积模块卷积和池化运算之后得到的尺寸为C*H*W的特征图，降维得到C个H*W的长向量，即每一个不同的卷积核对应的特征图分量，将这C个长向量两两做内积，该值对应Gij（Gram矩阵的第i行第j列的元素），得到一个C*C的Gram矩阵。得到的Gram矩阵捕捉了特征之间的相关性，反映了图像的纹理和模式信息，这些都是图像风格的重要组成部分。 </p><p>有了内容相似性和风格相似性的度量，我们就不难找到实现风格迁移的算法。对于固定的卷积神经网络，我们可以不断地调节生成图像，使其与原始图像之间的内容相似性和风格相似性同时实现最小化。因此，我们将风格迁移的问题成功地转化成了函数优化的问题。只不过，在这个任务中，待优化的变量不再是神经网络的权重（在风格迁移中，卷积神经网络的权重不会发生变化），而是生成图像本身，它的每一个像素都是可变的。</p><h3 id="使用的神经网络架构"><a href="#使用的神经网络架构" class="headerlink" title="使用的神经网络架构"></a>使用的神经网络架构</h3><p>在风格迁移问题中，卷积神经网络并不会被调整和优化，而是固定的。问题的关键是卷积神经网络要在多尺度正确地提炼输入图像的内容特征和风格特征，因此我们通常选取那些能够在分类任务上表现良好的大型网络，选择VGG作为卷积神经网络，负责在多尺度正确地提炼输入图像的内容特征和风格特征。思路是利用PyTorch的动态计算图和强大的backward()函数自动完成对生成图像的优化，思路是在原有的VGG网络基础上重新定义一个动态计算图。在这个新的计算图中，除了原有VGG网络的一层接一层的计算步骤以外，还包括内容损失和风格损失的计算步骤。我们通过一层层地遍历VGG网络，将每一层的神经模块(nn.Module)同时添加到新的计算图中，然后在相应的卷积层之后，添加内容损失和风格损失的计算模块来构建新的计算图。之后，我们只需要在这个新的动态计算图上执行反向传播算法，就可以对生成图像进行优化了。</p><h3 id="如何训练该神经网络-2"><a href="#如何训练该神经网络-2" class="headerlink" title="如何训练该神经网络"></a>如何训练该神经网络</h3><ul><li><p>内容损失和风格损失的定义<br>我们分别将原始图像和生成图像输入VGG网络，并计算该网络在第4层的两组输出，它们之间的均方误差可以定义为它们之间的内容损失。风格损失函数定义为目标风格图像在同一层的特征图的Gram矩阵与生成图像相应Gram矩阵的均方误差，由于风格既反映较低层特征的相关性，又反映较高层特征的相关性，是一个多尺度(multi-scale)因素，因此定义风格时应计算多层的Gram矩阵以及每一层的风格损失。最后，还需要对不同层的风格损失求平均，得到整张图像的平均风格损失。风格需在多个特征层上计算，因而图像风格损失表示为各层风格损失的加权和。</p></li><li><p>总损失函数<br>我们在综合考虑风格和内容损失时，可以将二者加权平均，从而得到一个总损失函数，有了损失函数，我们只需要利用反向传播算法，调用backward()函数，系统就会进行自动优化求解。但值得注意的是，对于风格迁移来说，我们的卷积神经网络并不会发生变化，所要调节的是输入的生成图像，因此，我们需要对这张图像上的每个像素点求梯度。于是，在反向传播算法的作用下，我们的生成图像会逐渐发生变化，直到达到令我们满意的效果为止。</p></li><li><p>优化器<br>优化器选用LBFGS，采用了L-BFGS优化算法来定义优化器。之所以选择这个算法，是因为它是擅长计算大规模数据的梯度下降算法。</p></li></ul><h1 id="总结：几乎所有的机器学习案例都采用了这样的步骤，即数据预处理；前馈运算；反向传播计算梯度、根据梯度更新参数值、迭代训练网络使模型性能达到最优；在测试集上测试模型性能（神经网络的准确率）。"><a href="#总结：几乎所有的机器学习案例都采用了这样的步骤，即数据预处理；前馈运算；反向传播计算梯度、根据梯度更新参数值、迭代训练网络使模型性能达到最优；在测试集上测试模型性能（神经网络的准确率）。" class="headerlink" title="总结：几乎所有的机器学习案例都采用了这样的步骤，即数据预处理；前馈运算；反向传播计算梯度、根据梯度更新参数值、迭代训练网络使模型性能达到最优；在测试集上测试模型性能（神经网络的准确率）。"></a>总结：几乎所有的机器学习案例都采用了这样的步骤，即数据预处理；前馈运算；反向传播计算梯度、根据梯度更新参数值、迭代训练网络使模型性能达到最优；在测试集上测试模型性能（神经网络的准确率）。</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单车预测器&quot;&gt;&lt;a href=&quot;#单车预测器&quot; class=&quot;headerlink&quot; title=&quot;单车预测器&quot;&gt;&lt;/a&gt;单车预测器&lt;/h2&gt;&lt;h3 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;</summary>
      
    
    
    
    
    <category term="DeepLearning" scheme="http://example.com/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>高并发服务器类图浅析</title>
    <link href="http://example.com/2024/03/21/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B1%BB%E5%9B%BE%E6%B5%85%E6%9E%90/"/>
    <id>http://example.com/2024/03/21/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B1%BB%E5%9B%BE%E6%B5%85%E6%9E%90/</id>
    <published>2024-03-21T11:43:11.000Z</published>
    <updated>2024-03-23T11:39:09.144Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/Reactor5.jpeg" alt="高并发服务器类图"><br>以上是小miu自己做的可以实现网络通信的高并发服务器类图，所有这些类协同工作，形成了一个高效的服务器框架。</p><p>服务器启动时，TcpServer 使用Acceptor来接受新连接，为每个新连接创建TcpConnection。EventLoop 负责分发事件，如IO读写事件，而ThreadPool 则用于处理这些事件可能需要的耗时操作，从而不会阻塞主事件循环。通过TaskQueue 和同步原语，如&#96;Mutex’和’Condition’，来管理线程间的任务分配和执行，保证线程安全。</p><p>在这个框架中，EventLoop通常会在主线程中运行，维持着事件循环，并且负责监听和处理来自各个TcpConnection的事件。当有新连接建立时，Acceptor会接受这个连接，并通知TcpServer。然后，TcpServer会为每个新的连接创建一个TcpConnection实例，并将其加入到事件循环中。这样，当数据到来或者需要发送数据时，相应的事件就会被触发，并且回调用户设定的处理函数。</p><p>TcpConnection中的数据读写操作可能会通过SocketIO进行，这样可以更高效地处理大量的数据传输。同时，TcpConnection还会有它的生命周期管理，包括连接的建立、维护和断开。</p><p>ThreadPool在这个过程中扮演着后台工作者的角色。它可以处理耗时的任务，比如数据的处理和响应生成，从而不会影响主事件循环的响应速度。TaskQueue作为任务的缓冲区，确保了任务的有序处理。</p><p>同步机制，例如MutexLock和Condition，确保了在多线程环境下，对共享资源的访问是安全的，没有竞态条件和死锁的发生。特别是MutexLockGuard，通过RAII机制，减少了因为异常或其他路径跳出而忘记释放锁的问题。</p><p>最后，EchoServer这样的特定实现类(即业务逻辑类)，则展示了如何利用这个框架来实现具体的应用逻辑。它会在接收到客户端数据后，简单地将接收到的数据返回给客户端。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/assets/Reactor5.jpeg&quot; alt=&quot;高并发服务器类图&quot;&gt;&lt;br&gt;以上是小miu自己做的可以实现网络通信的高并发服务器类图，所有这些类协同工作，形成了一个高效的服务器框架。&lt;/p&gt;
&lt;p&gt;服务器启动时，TcpServer 使用Accep</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记之多态与虚函数</title>
    <link href="http://example.com/2024/03/21/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2024/03/21/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/</id>
    <published>2024-03-21T09:43:24.000Z</published>
    <updated>2024-03-21T14:51:21.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态性与虚函数"><a href="#多态性与虚函数" class="headerlink" title="多态性与虚函数"></a>多态性与虚函数</h1><h2 id="多态性的概念"><a href="#多态性的概念" class="headerlink" title="多态性的概念"></a>多态性的概念</h2><p>多态的意思是指一个事物有多种形态。C++中，多态性是指具有不同功能的函数可以用同一个函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象时，多态性为：向不同的对象发送同一个消息，不同的对象会在接收时产生不同的行为。函数的重载和运算符的重载都是多态现象。</p><p>多态性分为2类：静态多态性和动态多态性。函数重载和运算符重载都属于静态多态性。<strong>静态多态</strong>的意思是：在程序编译时就能决定调用哪个函数。静态多态性是通过函数的重载实现的。<strong>动态多态</strong>是在程序运行过程中才动态确定操作指针所针对的对象。动态多态性是通过虚函数实现的。</p><p>当一个基类被继承为不同的派生类时，各派生类可以使用与基类成员相同的成员名，如果在运行期间调用类对象的成员，会产生二义性问题。</p><p>例 1.1建立一Point类，包含数据成员x,y（坐标点）。以它为基类，派生出一个Circle（圆）类，其中增加了数据成员半径r，再以Circle类为直接基类，派生出一个圆柱体类Cylinder，其中增加数据成员高度h。要求编写程序，重载运算符“&lt;&lt;”和“&gt;&gt;”，使之能用于输出以上类对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">float</span> x=<span class="number">0</span>,<span class="type">float</span> y=<span class="number">0</span>);<span class="comment">//有默认参数的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setpoint</span><span class="params">(<span class="type">float</span>,<span class="type">float</span>)</span></span>;<span class="comment">//设置坐标值</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;<span class="comment">//常成员函数可以引用本类中的数据成员，但不能修改他们</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getY</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line"><span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;,<span class="type">const</span> Point &amp;);重载输出运算符</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line"><span class="type">float</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">float</span> a,<span class="type">float</span> b)<span class="comment">//Point的构造函数</span></span><br><span class="line">&#123;x=a;y=b;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setpoint</span><span class="params">(<span class="type">float</span> a,<span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;x=a;y=b;&#125;</span><br><span class="line"><span class="comment">//重载运算符&lt;&lt;，使其可以输出点的坐标</span></span><br><span class="line">ostream &amp;<span class="keyword">operator</span> &lt;&lt; (ostream &amp;output, <span class="type">const</span> Point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">  output&lt;&lt;”[“&lt;&lt;p.x&lt;&lt;”.”&lt;&lt;p.y&lt;&lt;”]”&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="keyword">public</span> Point  <span class="comment">//Circle是Point类的公用派生类</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Circle</span>(<span class="type">float</span> x=<span class="number">0</span>,<span class="type">float</span> y=<span class="number">0</span>,<span class="type">float</span> r=<span class="number">0</span>);<span class="comment">//声明构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serRadius</span><span class="params">(<span class="type">float</span>)</span></span>;<span class="comment">//设置半径</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getRadius</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//读取半径</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//计算圆面积</span></span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span> &lt;&lt; (ostream &amp;, <span class="type">const</span> Circle &amp;);</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line"><span class="type">float</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line">Circle::<span class="built_in">Circle</span>(<span class="type">float</span> a,<span class="type">float</span> b,<span class="type">float</span> r):<span class="built_in">Point</span>(a,b)<span class="comment">//定义构造函数，对圆心坐标和半径进行初始化</span></span><br><span class="line">&#123;radius=r;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cirecle::setRadius</span><span class="params">(<span class="type">float</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;radius=r;&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Circle::getRadius</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> radius;&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Circle::area</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> <span class="number">3.14159</span>*radius*radius;&#125;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span> &lt;&lt;(ostream &amp;output,<span class="type">const</span> Circle &amp;c)</span><br><span class="line">&#123;</span><br><span class="line">  output&lt;&lt;”Center=[“&lt;&lt;c.x&lt;&lt;”.”&lt;&lt;c.y&lt;&lt;”],r=”&lt;&lt;c.radius&lt;&lt;”,area=”&lt;&lt;c.<span class="built_in">area</span>()&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cylinder</span>:<span class="keyword">public</span> Circle <span class="comment">//Cylinder是Circle的公用派生类</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cylinder</span>(<span class="type">float</span> x=<span class="number">0</span>,<span class="type">float</span> y=<span class="number">0</span>,<span class="type">float</span> r=<span class="number">0</span>,<span class="type">float</span> h=<span class="number">0</span>);<span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">float</span>)</span></span>;<span class="comment">//设置圆柱高度</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getHeight</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//读取圆柱高度</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//计算圆柱表面积</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">volume</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//计算圆柱体积</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp;, <span class="type">const</span> Cylinder&amp;);</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line"><span class="type">float</span> height;</span><br><span class="line">&#125;;</span><br><span class="line">Cylinder::<span class="built_in">Cylinder</span>(<span class="type">float</span> a,<span class="type">float</span> b,<span class="type">float</span> r,<span class="type">float</span> h):<span class="built_in">Circle</span>(a,b,r)<span class="comment">//定义构造函数</span></span><br><span class="line">&#123;height=h;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cylinder::setHeight</span><span class="params">(<span class="type">float</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;height=h;&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Cylinder::getHeight</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> height;&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Cylinder::area</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> <span class="number">2</span>*Circle::<span class="built_in">area</span>()+<span class="number">2</span>*<span class="number">3.14159</span>*radius*height;&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Cylinder::volume</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> Circle::<span class="built_in">area</span>()*height;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span> &lt;&lt; (ostream &amp;output,<span class="type">const</span> Cylinder &amp;cy)</span><br><span class="line">&#123; output&lt;&lt;”Center=[“&lt;&lt;cy.x&lt;&lt;”,”&lt;&lt;cy.y&lt;&lt;”],r=”&lt;&lt;cy.radius&lt;&lt;”,h=”&lt;&lt;cy.height&lt;&lt;”\narea= “&lt;&lt;cy.<span class="built_in">area</span>()&lt;&lt;” ,volume=”&lt;&lt;cy.<span class="built_in">volume</span>()&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Cylinder <span class="title">cy1</span><span class="params">(<span class="number">3.5</span>,<span class="number">6.4</span>,<span class="number">5.2</span>,<span class="number">10</span>)</span></span>;<span class="comment">//定义Cylinder类对象cy1</span></span><br><span class="line">  cout&lt;&lt;”\noriginal cylinder: \nx=”&lt;&lt;cy1.<span class="built_in">getX</span>()&lt;&lt;” ,y=”&lt;&lt;cy1.<span class="built_in">getY</span>()&lt;&lt;” ,r”=cy1.<span class="built_in">getRadius</span>() &lt;&lt;” ,h=”&lt;&lt;cy1.<span class="built_in">getHeight</span>()&lt;&lt;”\narea=”&lt;&lt;cy1.<span class="built_in">area</span>()&lt;&lt;” ,volume=”&lt;&lt;cy1.<span class="built_in">volume</span>()&lt;&lt;endl;</span><br><span class="line">  <span class="comment">//Cylinder类中也定义了area函数，发生同名覆盖</span></span><br><span class="line">  cy1.<span class="built_in">setHeight</span>(<span class="number">15</span>);</span><br><span class="line">  cy1.<span class="built_in">setRadius</span>(<span class="number">7.5</span>);</span><br><span class="line">  cy1.<span class="built_in">setPoint</span>(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">  cout&lt;&lt;”\nnew cylinder: \n”&lt;&lt;cy1;<span class="comment">//用重载运算符&lt;&lt;输出cy1的数据</span></span><br><span class="line">  Point &amp;Ref=cy1;<span class="comment">//pRef是Point类对象的引用</span></span><br><span class="line">  cout&lt;&lt;”\npRef as a Point:”&lt;&lt;pRef;<span class="comment">//pRef作为一个点输出，只是基类部分(Point)的别名</span></span><br><span class="line">  Circle &amp;cRef=cy1; <span class="comment">//cRef是Circle类对象的引用</span></span><br><span class="line">  cout&lt;&lt;”\ncRef as a Circle:”&lt;&lt;cRef;<span class="comment">//cRef作为一个圆输出，只是基类部分(Circle)的别名</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="虚函数的作用"><a href="#虚函数的作用" class="headerlink" title="虚函数的作用"></a>虚函数的作用</h3><p>在类的继承层次结构中，不同的层次中可以出现名字相同，参数个数和类型都相同而功能不同的函数。如例1.2中Circle类的area函数和Circle派生类Cylinder中的area函数，它们名字相同，参数个数均为0，但是功能不同。会发生同名覆盖。能否调用同一个形式，既能调用派生类又能调用基类的同名函数。C++提供了虚函数来解决上述中的同名覆盖问题。</p><p>简单地说，那些被关键字virtual声明的成员函数就是虚函数。虚函数的作用是允许在派生类中重新定义与基类同名的的函数，并可以通过智能指针或引用来访问基类和派生类中的同名函数。</p><p>虚函数形式：在基类声明函数时，在最左侧加一个关键字virtual。且当一个成员函数被声明为虚函数时，其派生类的同名成员函数自动成为虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;<span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;<span class="comment">//在声明基类时，将成员函数声明为虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graduate</span>: <span class="keyword">public</span> Student</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student stud1;</span><br><span class="line">  Graduate grad1;</span><br><span class="line">  Student *p;<span class="comment">//p是一个基类指针，可以调用同一类族中不同类的虚函数</span></span><br><span class="line">  p=&amp;stud1;</span><br><span class="line">  (*p).<span class="built_in">display</span>();</span><br><span class="line">  p=&amp;grad1;</span><br><span class="line">  (*p).<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用同一个基类指针变量，可以调用同一组类中的不同虚函数。</strong>本来基类指针是用来指向派生类对象中的基类部分的，无法通过基类指针调用派生类对象的中的成员函数的。虚基类突破了这一限制，在派生类的基类部分中，派生类的虚函数取代了基类原来的虚函数，因此当积累指针指向派生类对象后，调用虚函数时就调用了派生类的虚函数。虚函数的使用方法为：</p><ul><li><p>在基类中用virtual声明成员函数为虚函数，这样就可以在派生类中重新定义此函数，为它赋予新的功能，并能方便的调用。</p></li><li><p>在派生类中重新定义此函数，要求函数名，函数类型，函数参数个数和类型全部与基类的虚函数相同，并根据派生类的需要重新定义函数体。</p></li><li><p>定义一个指向基类对象的指针变量，并使它指向同一类族中需要调用该函数的对象。</p></li><li><p>通过指针变量调用此虚函数，此时调用的就是指针变量所指向的对象的同名函数。</p></li></ul><p><strong>通过虚函数与指向基类对象的指针变量的配合使用</strong>，就能方便地调用同一类族中不同类的同名函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多态性与虚函数&quot;&gt;&lt;a href=&quot;#多态性与虚函数&quot; class=&quot;headerlink&quot; title=&quot;多态性与虚函数&quot;&gt;&lt;/a&gt;多态性与虚函数&lt;/h1&gt;&lt;h2 id=&quot;多态性的概念&quot;&gt;&lt;a href=&quot;#多态性的概念&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>为什么要学习Linux?</title>
    <link href="http://example.com/2024/03/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0Linux/"/>
    <id>http://example.com/2024/03/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0Linux/</id>
    <published>2024-03-17T12:48:21.000Z</published>
    <updated>2024-03-17T13:13:24.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>很简单，也很直接一个原因：很多互联网大公司都有大量的服务器运行在基于 Linux 的操作系统。因此，我们工作不可避免会接触 Linux 系统。<br>不过，也要看岗位：<br>对于后端开发岗、运维岗都需要用到Linux。<br>之所以服务器选择用 Linux 操作系统，原因有很多：</p><ul><li><p>自由开源：Linux 操作系统完全免费且可用作开源软件，通过开源方式，您可以轻松查看用于创建 Linux 内核的可用代码，还可以修改代码以修复任何错误等。只要你做够厉害，你完全可以按照自己的方式构建和自定义服务器。这些是在 windows 上无法实现的。</p></li><li><p>稳定性：在 windows 上，我们进程看到系统崩溃或者卡死，但是在 Linux 上，这种情况发生的几率极小，Linux 系统以其最终的稳定性而闻名。</p></li><li><p>成本低：Linux 是免费的，如果你想在其中一台服务器上安装 Windows，则需要支付激活费用，这意味着你需要多花一笔钱。</p></li><li><p>操作方便：对于普通人来说，Windows 操作更为快捷，但是对计算机专业人士来讲，Linux 操作比 Windows 快捷的多，几条命令就可以执行很多的操作。</p></li></ul><h2 id="接下来，和大家聊聊怎么学习Linux"><a href="#接下来，和大家聊聊怎么学习Linux" class="headerlink" title="接下来，和大家聊聊怎么学习Linux?"></a>接下来，和大家聊聊怎么学习Linux?</h2><p>Linux 学习主要有三个方向：</p><ul><li><p>Linux 命令：Linux 系统都是命令式操作的，就是比如你要创建一个文件、查看一个文件、删除一个文件等，都是需要输入命令， 所以要熟练用起 Linux 系统，命令的熟悉是必不可少的。</p></li><li><p>Linux 脚本：熟悉了基本 Linux 命令后，就可以去学习 Linux 脚本，其实很简单，就是把各种命令写在一个脚本文件里，执行脚本的时候就会把所有命令执行一遍，用于自动部署一些项目。</p></li><li><p>Linux 编程（系统编程&#x2F;网络编程）：如果走 C&#x2F;C++ 开发，这一块就需要学习，因为 Linux 系统是由 C 语言开发的，所以系统调用接口，都是 C 式编程开发的。</p></li></ul><p>我们可以在自己的 Windows 电脑装一个虚拟机，然后装一个 centos 或 ubuntu 发行版本的 Linux，网上的安装资源很多的，自己搜一搜跟着搭建就行。有条件可以买一个云服务器，使用起来会更方便一些，因为有公网 ip 地址，任何时候都可以远程登录使用。</p><h2 id="再聊聊我学习Linux的心得"><a href="#再聊聊我学习Linux的心得" class="headerlink" title="再聊聊我学习Linux的心得"></a>再聊聊我学习Linux的心得</h2><p>在学网络编程的时候，看见网上的人都说 UNP（Unix 网络编程）、APUE（Unix 高级环境编程）这两本书是网络编程圣经的书，但是书实在是太厚了，小miu不知从何看起</p><p>后面我又重新找了一波关于网络编程的书，找到了这两本：《TCP&#x2F;IP 网络编程》和《Linux高性能服务器编程》。</p><ul><li><p>《TCP&#x2F;IP 网络编程》绝对是新手村级别的书，书里的内容不会有过多的术语，作者都用大白话来表达，配图也很清晰，也有介绍我想知道的网络框架，虽然是比较基础的多进程服务端模型、多线程服务端模型、异步 IO 模型。而且最后一章实现了简单的 HTTP 服务端，让我知道了从代码角度是怎么解析 HTTP 报文的，以及状态机是如何实现和运转的。</p></li><li><p>《Linux高性能服务器编程》这本书主要是网络框架为主，前几章关于网络基础知识对于掌握了计算机网络知识的同学可以直接跳过的，你看，很多知识是想通的，当我们知道掌握了这块知识后，在学习新一本书的时候，就可以跳过重叠的内容。在这本书我学到了，Reactor、Proactor、信号、定时器、多进程编程、多线程编程、进程池和线程池等。<br>这两本书让我大概知道了如果一个服务端要服务多个客户端时，不是就简单写个 socket 编程就完事，而是还要结合 IO 多路复用 + 多线程的思想，也就是 Reactor 的设计理念，知道了这些事情后，后面我在看很多开源框架的网络模型时候，发现大多数基于 Reactor 的思想来实现的。</p></li></ul><p>有了网络编程总体的视角后，在需要深入理解 socket api 中各种属性设置（超时、非阻塞 IO、阻塞 IO 等）和异常处理就要回归 APUE 这本书。</p><p>到这里我才知道 UNP 和 APUE 为什么会被称为网络编程圣经级别的书，原因是书里各种细节和异常都写的很全，也很细致，可以应对工作中很多问题。</p><p>但是事实证明，它并不是个入门级的书，所以 UNP 和 APUE 的用途比较像字典，在需要的时候去查阅就好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h2&gt;&lt;p&gt;很简单，也很直接一个原因：很多互联网大公司都有大量的服务器运行在基于 Linux 的操作系统。因此，我们工作不可避免会接触 Linux 系统</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用和Reactor实现高并发</title>
    <link href="http://example.com/2024/03/17/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8CReactor%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <id>http://example.com/2024/03/17/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8CReactor%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91/</id>
    <published>2024-03-17T12:46:51.000Z</published>
    <updated>2024-03-23T11:10:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>小miu之前毕业季找工作时做了一个基于Linux的搜索引擎服务器项目，今天通过这篇博客让我们以最简单 socket 网络模型，一步一步的过度到 I&#x2F;O 多路复用，再到Reactor网络模型实现高并发。</p><h2 id="socket网络模型"><a href="#socket网络模型" class="headerlink" title="socket网络模型"></a>socket网络模型</h2><p>要想客户端和服务器能在网络中通信，那必须得使用 Socket  编程，它是进程间通信里比较特别的方式，特别之处在于它是可以跨主机间通信。在计算机网络中，Socket编程主要用于实现基于TCP&#x2F;IP协议的网络通信。TCP&#x2F;IP是一种传输控制协议&#x2F;互联网协议，它定义了如何在网络上发送数据。使用Socket进行编程时，通常会涉及以下几个主要步骤：</p><ul><li><p>创建Socket：首先，通信的每一方都需要创建一个Socket。在创建Socket时，可以指定使用的协议（如TCP或UDP）、目标IP地址以及端口号。</p></li><li><p>监听连接（仅限服务器端）：在服务器端，需要将创建的Socket配置为监听模式，等待客户端的连接请求。</p></li><li><p>建立连接：客户端通过指定服务器的IP地址和端口号来请求与服务器建立连接。服务器端接收到请求后，确认并建立连接。</p></li><li><p>数据据交换：一旦连接建立，客户端和服务器端就可以通过创建的连接互相发送和接收数据了。</p></li><li><p>关闭连接：数据传输完成后，双方可以关闭连接，释放资源。</p></li></ul><p>虽然我们的Linux内核提供了socket()系统调用函数，但是在使用C++或其他任何编程语言写一个服务器端时，应该在用户空间创建一个socket类，然后通过这个类来调用底层的系统调用socket(),通过将socket()函数作为类的成员函数来实现，这样使得处理网络通信变得更容易、代码更清晰。</p><p>服务器的程序要先跑起来，然后等待客户端的连接和数据，我们先来看看服务端的 Socket 编程过程是怎样的。</p><p>服务端首先调用 socket() 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket ，接着调用 bind() 函数，给这个 Socket 绑定一个 IP 地址和端口，绑定这两个的目的是什么？</p><ul><li><p>绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。</p></li><li><p>绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们；</p></li></ul><p>绑定完 IP 地址和端口后，就可以调用 listen() 函数进行监听，如果我们要判定服务器中一个网络程序有没有启动，可以通过 netstate 命令查看对应的端口号是否有被监听。</p><p>服务端进入了监听状态后，通过调用 accept() 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。</p><p>那客户端是怎么发起连接的呢？客户端在创建好 Socket 后，调用 connect() 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后万众期待的 TCP 三次握手就开始了。<br>在  TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：</p><ul><li><p>一个是还没完全建立连接的队列，称为 TCP 半连接队列，这个队列都是没有完成三次握手的连接，此时服务端处于 syn_rcvd 的状态；</p></li><li><p>一个是一件建立连接的队列，称为 TCP 全连接队列，这个队列都是完成了三次握手的连接，此时服务端处于 established 状态；</p></li></ul><p>当 TCP 全连接队列不为空后，服务端的 accept() 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的  Socket 返回应用程序，后续数据传输都用这个 Socket。</p><p>注意，监听的 Socket 和真正用来传数据的 Socket 是两个：</p><ul><li><p>一个叫作监听 Socket；</p></li><li><p>一个叫作已连接 Socket；</p></li></ul><p>连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 read() 和 write() 函数来读写数据。</p><p>至此， TCP 协议的 Socket 程序的调用过程就结束了，整个过程如下图：<br><img src="/assets/Socket.png" alt="Socket程序调用过程"></p><p>这里要说明一点，为什么客户端不用 bind() 来绑定ip和端口号呢？因为当客户端发起连接时，操作系统会为该连接自动分配一个临时的端口号，这被称为“动态端口分配”或“临时端口”。这个过程对于应用程序来说是透明的，使得应用程序无需关心端口的具体分配问题。这种机制允许多个客户端应用并发地与服务器或其他服务建立连接，而不会因为端口冲突而导致失败。</p><p>基于Linux中一切皆文件的理念，当我们完成网络双方连接的建立，准备数据通信时，此时有一个问题，那就是通信双方发送数据时从哪个文件里读取，接收数据又是写入哪个文件呢？</p><p>在内核中 Socket 也是以「文件」的形式存在的，也是有对应的文件描述符。数据的收发就是Socket文件的读取和写入。</p><p>文件描述符的作用是什么？每一个进程都有一个数据结构 task_struct，该结构体里有一个指向「文件描述符数组」的成员指针。该数组里列出这个进程打开的所有文件的文件描述符。数组的下标是文件描述符，是一个整数，而数组的内容是一个指针，指向内核中所有打开的文件的列表，也就是说内核可以通过文件描述符找到对应打开的文件。</p><p>然后每个文件都有一个 inode，Socket 文件的 inode 指向了内核中的 Socket 结构，在这个结构体里有两个队列，分别是发送队列和接收队列，这个两个队列里面保存的是一个个 struct sk_buff，用链表的组织形式串起来。</p><p>sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。</p><h2 id="如何服务更多用户？"><a href="#如何服务更多用户？" class="headerlink" title="如何服务更多用户？"></a>如何服务更多用户？</h2><p>前面提到的 TCP Socket 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是同步阻塞的方式，当服务端在还没处理完一个客户端的网络 I&#x2F;O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。</p><p>可如果我们服务器只能服务一个客户，那这样就太浪费资源了，于是我们要改进这个网络 I&#x2F;O 模型，以支持更多的客户端。</p><h2 id="多进程模型"><a href="#多进程模型" class="headerlink" title="多进程模型"></a>多进程模型</h2><p>基于最原始的阻塞网络 I&#x2F;O， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用多进程模型，也就是为每个客户端分配一个进程来处理请求。</p><p>服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 fork() 函数创建一个子进程，实际上就把父进程所有相关的东西都复制一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。</p><p>这两个进程刚复制完的时候，几乎一摸一样。不过，会根据<strong>返回值</strong>来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。正因为<strong>子进程会复制父进程的文件描述符</strong>，于是就可以直接使用「已连接 Socket 」和客户端通信了，可以发现，子进程不需要关心「监听 Socket」，只需要关心「已连接 Socket」；父进程则相反，将客户服务交给子进程来处理，因此父进程不需要关心「已连接 Socket」，只需要关心「监听 Socket」。<br><img src="/assets/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="父进程创建子进程为客户端服务"></p><p>另外，当「子进程」退出时，实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作，就会变成僵尸进程，随着僵尸进程越多，会慢慢耗尽我们的系统资源。</p><p>因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，分别是调用 wait() 和 waitpid() 函数。</p><p>这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，性能会大打折扣。</p><p>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>既然进程间上下文切换的“包袱”很重，那我们就搞个比较轻量级的模型来应对多用户的请求 —— <strong>多线程模型</strong>。</p><p>线程是运行在进程中的一个“逻辑流”，单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源的，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时是不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。</p><p>当服务器与客户端 TCP 完成连接后，通过 pthread_create() 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。</p><p>如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。</p><p>那么，我们可以使用线程池的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里取一个线程负责从队列中取出已连接 Socket 进程处理。</p><p>需要注意的是，这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。</p><p>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程&#x2F;线程，操作系统就算死扛也是扛不住。</p><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h2><p>既然为每个请求分配一个进程&#x2F;线程的方式不合适，那有没有可能只使用一个进程来维护多个 Socket 呢？答案是有的，那就是 <strong>I&#x2F;O 多路复用技术</strong>。<br><img src="/assets/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="一个进程维护多个Socket"></p><p>一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。</p><p>我们熟悉的 select&#x2F;poll&#x2F;epoll 内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核中获取多个事件。</p><p>select&#x2F;poll&#x2F;epoll 是如何获取网络事件的呢？在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。</p><p>select&#x2F;poll&#x2F;epoll 这是三个多路复用接口，都能实现 C10K 吗？接下来，我们分别说说它们。</p><h3 id="select-poll"><a href="#select-poll" class="headerlink" title="select&#x2F;poll"></a>select&#x2F;poll</h3><p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。</p><p>所以，对于 select 这种方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符。</p><p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p><p>但是 poll 和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 通过两个方面，很好解决了 select&#x2F;poll 的问题。</p><ul><li><p>第一点，epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删查一般时间复杂度是 O(logn)，通过对这棵黑红树进行操作，这样就不需要像 select&#x2F;poll 每次操作时都传入整个 socket 集合，只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p></li><li><p>第二点， epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p></li></ul><p>从下图你可以看到 epoll 相关的接口作用:<br><img src="/assets/epoll.png" alt="epoll优化之处"></p><p>epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。这就是epoll相对于select&#x2F;poll的真正优化之处，以O(logn)的时间复杂度检测到并且返回已连接的Socket文件描述符。</p><h2 id="Reactor高性能网络"><a href="#Reactor高性能网络" class="headerlink" title="Reactor高性能网络"></a>Reactor高性能网络</h2><p>如果要让服务器服务多个客户端，那么最直接的方式就是为每一条连接创建线程。</p><p>其实创建进程也是可以的，原理是一样的，进程和线程的区别在于线程比较轻量级些，线程的创建和线程间切换的成本要小些，为了描述简述，后面都以线程为例。</p><p>处理完业务逻辑后，随着连接关闭后线程也同样要销毁了，但是这样不停地创建和销毁线程，不仅会带来性能开销，也会造成浪费资源，而且如果要连接几万条连接，创建几万个线程去应对也是不现实的。</p><p>要这么解决这个问题呢？我们可以使用「资源复用」的方式。</p><p>也就是不用再为每个连接创建线程，而是创建一个「线程池」，将连接分配给线程，然后一个线程可以处理多个连接的业务。</p><p>不过，这样又引来一个新的问题，线程怎样才能高效地处理多个连接的业务？</p><p>当一个连接对应一个线程时，线程一般采用「read -&gt; 业务处理 -&gt; send」的处理流程，如果当前连接没有数据可读，那么线程会阻塞在 read 操作上（ socket 默认情况是阻塞 I&#x2F;O），不过这种阻塞方式并不影响其他线程。</p><p>但是引入了线程池，那么一个线程要处理多个连接的业务，线程在处理某个连接的 read 操作时，如果遇到没有数据可读，就会发生阻塞，那么线程就没办法继续处理其他连接的业务。要解决这一个问题，最简单的方式就是将 socket 改成非阻塞，然后线程不断地轮询调用 read 操作来判断是否有数据，这种方式虽然该能够解决阻塞的问题，但是解决的方式比较粗暴，因为轮询是要消耗 CPU 的，而且随着一个 线程处理的连接越多，轮询的效率就会越低。</p><p>上面的问题在于，线程并不知道当前连接是否有数据可读，从而需要每次通过 read 去试探。那有没有办法在只有当连接上有数据的时候，线程才去发起读请求呢？答案是有的，实现这一技术的就是 I&#x2F;O 多路复用。</p><p>I&#x2F;O 多路复用技术会用一个系统调用函数来监听我们所有关心的连接，也就说可以在一个监控线程里面监控很多的连接。我们熟悉的 select&#x2F;poll&#x2F;epoll 就是内核提供给用户态的多路复用系统调用，线程可以通过一个系统调用函数从内核中获取多个事件(获取事件就是看Socket连接上有没有数据)。<br>select&#x2F;poll&#x2F;epoll 是如何获取网络事件的呢？</p><p>在获取事件时，先把我们要关心的连接传给内核，再由内核检测：</p><ul><li><p>如果没有事件发生，线程只需阻塞在这个系统调用，而无需像前面的线程池方案那样轮训调用 read 操作来判断是否有数据。</p></li><li><p>如果有事件发生，内核会返回产生了事件的连接，线程就会从阻塞状态返回，然后在用户态中再处理这些连接对应的业务即可。</p></li></ul><p>大佬们基于面向对象的思想，对 I&#x2F;O 多路复用作了一层封装，让使用者不用考虑底层网络 API 的细节，只需要关注应用代码的编写。</p><p>大佬们还为这种模式取了个让人第一时间难以理解的名字：Reactor 模式。</p><p>Reactor 翻译过来的意思是「反应堆」，可能大家会联想到物理学里的核反应堆，实际上并不是的这个意思。</p><p>这里的反应指的是「对事件反应」，也就是来了一个事件，Reactor 就有相对应的反应&#x2F;响应。</p><p>事实上，Reactor 模式也叫 Dispatcher 模式，我觉得这个名字更贴合该模式的含义，即 I&#x2F;O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 &#x2F; 线程。</p><p>Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下：</p><ul><li><p>Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；</p></li><li><p>处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；<br>Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：</p></li></ul><p>Reactor 的数量可以只有一个，也可以有多个；</p><p>处理资源池可以是单个进程 &#x2F; 线程，也可以是多个进程 &#x2F;线程；</p><p>将上面的两个因素排列组设一下，理论上就可以有 4 种方案选择：</p><ul><li><p>单 Reactor 单进程 &#x2F; 线程；</p></li><li><p>单 Reactor 多进程 &#x2F; 线程；</p></li><li><p>多 Reactor 单进程 &#x2F; 线程；</p></li><li><p>多 Reactor 多进程 &#x2F; 线程；</p></li></ul><p>其中，「多 Reactor 单进程 &#x2F; 线程」实现方案相比「单 Reactor 单进程 &#x2F; 线程」方案，不仅复杂而且也没有性能优势，因此实际中并没有应用。</p><p>剩下的 3 个方案都是比较经典的，且都有应用在实际的项目中：</p><ul><li><p>单 Reactor 单进程 &#x2F; 线程；</p></li><li><p>单 Reactor 多线程 &#x2F; 进程；</p></li><li><p>多 Reactor 多进程 &#x2F; 线程；</p></li></ul><p>下面根据小miu做得服务器项目，只介绍前两种方案（因为第三种没用过）</p><h3 id="单-Reactor-单进程-线程"><a href="#单-Reactor-单进程-线程" class="headerlink" title="单 Reactor 单进程 &#x2F; 线程"></a>单 Reactor 单进程 &#x2F; 线程</h3><p><img src="/assets/r01.png" alt="单Reactor单进程或线程"></p><p>可以看到进程里有 Reactor、Acceptor、Handler 这三个对象：</p><ul><li><p>Reactor 对象的作用是监听和分发事件；</p></li><li><p>Acceptor 对象的作用是获取连接；</p></li><li><p>Handler 对象的作用是处理业务；</p></li></ul><p>对象里的 select、accept、read、send 是系统调用函数，dispatch 和 「业务处理」是需要完成的操作，其中 dispatch 是分发事件操作。</p><p>接下来，介绍下「单 Reactor 单进程」这个方案：</p><p>Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；</p><ul><li><p>如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；</p></li><li><p>如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；</p></li><li><p>Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</p></li></ul><p>单 Reactor 单进程的方案因为全部工作都在同一个进程内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心多进程竞争。</p><p>但是，这种方案存在 2 个缺点：</p><ul><li><p>第一个缺点，因为只有一个进程，无法充分利用 多核 CPU 的性能；</p></li><li><p>第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，如果业务处理耗时比较长，那么就造成响应的延迟；</p></li></ul><p>所以，单 Reactor 单进程的方案不适用计算机密集型的场景，只适用于业务处理非常快速的场景。</p><h3 id="单-Reactor-多线程-多进程"><a href="#单-Reactor-多线程-多进程" class="headerlink" title="单 Reactor 多线程 &#x2F; 多进程"></a>单 Reactor 多线程 &#x2F; 多进程</h3><p><img src="/assets/r02.png" alt="单Rractor多线程或进程"></p><p>详细说一下这个方案：</p><ul><li><p>Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；</p></li><li><p>如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；</p></li><li><p>如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；</p></li></ul><p>上面的三个步骤和单 Reactor 单线程方案是一样的，接下来的步骤就开始不一样了：</p><ul><li><p>Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理；</p></li><li><p>子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client；</p></li></ul><p>单 Reator 多线程的方案优势在于能够充分利用多核 CPU 的能，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。</p><p>例如，子线程完成业务处理后，要把结果传递给主线程的 Reactor 进行发送，这里涉及共享数据的竞争。</p><p>要避免多线程由于竞争共享资源而导致数据错乱的问题，就需要在操作共享资源前加上互斥锁，以保证任意时间里只有一个线程在操作共享资源，待该线程操作完释放互斥锁后，其他线程才有机会操作共享数据。</p><p>聊完单 Reactor 多线程的方案，接着来看看单 Reactor 多进程的方案。</p><p>事实上，单 Reactor 多进程相比单 Reactor 多线程实现起来很麻烦，主要因为要考虑子进程 &lt;-&gt; 父进程的双向通信，并且父进程还得知道子进程要将数据发送给哪个客户端。</p><p>而多线程间可以共享数据，虽然要额外考虑并发问题，但是这远比进程间通信的复杂度低得多，因此实际应用中也看不到单 Reactor 多进程的模式。</p><p>另外，「单 Reactor」的模式还有个问题，因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;小miu之前毕业季找工作时做了一个基于Linux的搜索引擎服务器项目，今天通过这篇博客让我们以最简单 socket 网络模型，一步一步的过度到 I&amp;#x2F;O 多路复用，再到Reactor网络模型实现高并发。&lt;/p&gt;
&lt;h2 id=&quot;socket网络模型&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>前端与后端的联系与区别，一次性说清楚</title>
    <link href="http://example.com/2024/03/09/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%90%8E%E7%AB%AF%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%B8%80%E6%AC%A1%E6%80%A7%E8%AF%B4%E6%B8%85%E6%A5%9A/"/>
    <id>http://example.com/2024/03/09/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%90%8E%E7%AB%AF%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%B8%80%E6%AC%A1%E6%80%A7%E8%AF%B4%E6%B8%85%E6%A5%9A/</id>
    <published>2024-03-09T08:10:17.000Z</published>
    <updated>2024-03-09T08:40:42.367Z</updated>
    
    <content type="html"><![CDATA[<p>前端和后端是软件开发中的两个核心概念。尤其是在Web开发中。</p><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>  前端（Front-end），也称为客户端，主要关注于用户界面和用户体验的部分。前端开发的目标是通过HTML、CSS和JavaScript等技术，创建用户可以直接看到并与之交互的网页或应用界面。前端开发者负责设计和实现网页的布局、外观、以及响应用户操作的动态功能。</p><h2 id="前端技术栈："><a href="#前端技术栈：" class="headerlink" title="前端技术栈："></a>前端技术栈：</h2><p>  HTML、CSS、JavaScript是构建前端的三大基石。此外，还有诸如React、Vue、Angular等现代JavaScript框架和库，它们使得开发复杂的单页应用（SPA）变得更加高效和组织化。</p><h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><p>后端（Back-end），也称为服务器端，主要关注于服务器、数据库、以及应用的逻辑部分。后端开发的目标是创建和维护网站的核心功能逻辑，如数据存储、服务器与客户端之间的通信、用户身份验证等。后端开发者需要处理数据库管理、服务器配置、以及使用服务器端语言编写应用逻辑。</p><h2 id="后端技术栈："><a href="#后端技术栈：" class="headerlink" title="后端技术栈："></a>后端技术栈：</h2><p>常见的后端技术包括服务器端语言如Node.js、C++、Python、Ruby、Java和PHP等。数据库技术如MySQL、MongoDB、PostgreSQL等，以及服务器技术如Nginx和Apache。</p><h2 id="虽然前端和后端有明显的区别，但它们是相互依赖的，共同构成了完整的web应用或服务。前端需要后端提供数据和服务接口，而后端需要前端展示数据和提供用户交互。这种协作确保了用户能够在网页或应用上享受到流畅且功能完备的体验。"><a href="#虽然前端和后端有明显的区别，但它们是相互依赖的，共同构成了完整的web应用或服务。前端需要后端提供数据和服务接口，而后端需要前端展示数据和提供用户交互。这种协作确保了用户能够在网页或应用上享受到流畅且功能完备的体验。" class="headerlink" title="虽然前端和后端有明显的区别，但它们是相互依赖的，共同构成了完整的web应用或服务。前端需要后端提供数据和服务接口，而后端需要前端展示数据和提供用户交互。这种协作确保了用户能够在网页或应用上享受到流畅且功能完备的体验。"></a>虽然前端和后端有明显的区别，但它们是相互依赖的，共同构成了完整的web应用或服务。前端需要后端提供数据和服务接口，而后端需要前端展示数据和提供用户交互。这种协作确保了用户能够在网页或应用上享受到流畅且功能完备的体验。</h2><h1 id="C-在后端开发中的优势与限制"><a href="#C-在后端开发中的优势与限制" class="headerlink" title="C++在后端开发中的优势与限制"></a>C++在后端开发中的优势与限制</h1><p>C++在后端开发中的应用并非面向所有类型的项目，但它在某些特定领域非常受欢迎，原因主要包括以下几点：</p><ul><li><p>性能优势：C++以其出色的性能和高效的资源管理著称。对于需要处理高并发请求、大量数据处理、或复杂计算的后端系统来说，C++能提供比许多其他语言更优的性能表现。这对于实时交易系统、高频交易平台、游戏服务器、大规模数值计算等场景尤其重要。</p></li><li><p>系统级别的控制：C++提供了对系统资源的低级别控制能力，包括内存管理和硬件接口。这使得开发者能够优化程序的性能，并直接管理内存使用和系统调用，这对于需要精细资源管理的后端服务来说是一个巨大的优势。</p></li><li><p>跨平台性：C++代码可以在多种操作系统上编译运行，包括Windows、Linux和MacOS。这种跨平台特性使得C++成为开发高性能服务器应用的理想选择，尤其是在需要支持多个操作系统环境的情况下。</p></li><li><p>成熟的生态系统：C++拥有广泛的开发工具、库和框架支持，这些资源使得开发复杂的后端服务变得更加容易。标准模板库（STL）提供了丰富的数据结构和算法，而Boost库等第三方库则扩展了C++的功能，覆盖网络通信、多线程处理、数学计算等多个领域。</p></li></ul><h2 id="不过C-存在一定的学习曲线和开发复杂度，因此，是否选择C-进行后端开发很大程度上取决于项目的具体需求、性能目标以及团队的技术栈偏好。对于不需要极致性能或低级资源管理的应用，使用更高级的语言如Python、Java或Node-js可能会更加高效和便利。"><a href="#不过C-存在一定的学习曲线和开发复杂度，因此，是否选择C-进行后端开发很大程度上取决于项目的具体需求、性能目标以及团队的技术栈偏好。对于不需要极致性能或低级资源管理的应用，使用更高级的语言如Python、Java或Node-js可能会更加高效和便利。" class="headerlink" title="不过C++存在一定的学习曲线和开发复杂度，因此，是否选择C++进行后端开发很大程度上取决于项目的具体需求、性能目标以及团队的技术栈偏好。对于不需要极致性能或低级资源管理的应用，使用更高级的语言如Python、Java或Node.js可能会更加高效和便利。"></a>不过C++存在一定的学习曲线和开发复杂度，因此，是否选择C++进行后端开发很大程度上取决于项目的具体需求、性能目标以及团队的技术栈偏好。对于不需要极致性能或低级资源管理的应用，使用更高级的语言如Python、Java或Node.js可能会更加高效和便利。</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前端和后端是软件开发中的两个核心概念。尤其是在Web开发中。&lt;/p&gt;
&lt;h1 id=&quot;前端&quot;&gt;&lt;a href=&quot;#前端&quot; class=&quot;headerlink&quot; title=&quot;前端&quot;&gt;&lt;/a&gt;前端&lt;/h1&gt;&lt;p&gt;  前端（Front-end），也称为客户端，主要关注于用户界面</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>反向传播算法是如何让发挥作用的？</title>
    <link href="http://example.com/2024/03/08/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A9%E5%8F%91%E6%8C%A5%E4%BD%9C%E7%94%A8%E7%9A%84%EF%BC%9F/"/>
    <id>http://example.com/2024/03/08/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A9%E5%8F%91%E6%8C%A5%E4%BD%9C%E7%94%A8%E7%9A%84%EF%BC%9F/</id>
    <published>2024-03-08T15:23:49.000Z</published>
    <updated>2024-03-09T07:13:33.266Z</updated>
    
    <content type="html"><![CDATA[<p>  反向传播算法可以调整人工神经网络中出问题的“组件”，降低神经网络预测或者分类的错误率，提高模型的准确率，从而提高效率。那么反向传播算法是如何发挥作用的呢？<br>  对于每个神经网络来说，都有输入神经元与输出神经元，输入神经元到输出神经元的映射可以描述为一个函数，这个函数就是激活函数。对于神经网络的数据集，分为两训练集和测试集两大类。训练集可以抽象为实际输入的数据，测试集是模型计算得到输出后与实际的数据进行比对，从而判断模型预测或者分类的准确率。那么由实际输出与实际测试数据两个变量之间可以定义一个损失函数，用来表示模型的误差函数。我们的目的就是要让损失函数的值最小。这个时候，网络中各个节点的梯度信息就闪亮登场了，梯度其实就是损失函数对于网络中各个权重的导数，当这个导数无限趋近于0的时候，可以认为在这个权重下损失函数取到极小值。<br>  反向传播算法发挥作用的具体步骤如下：</p><h2 id="计算输出误差"><a href="#计算输出误差" class="headerlink" title="计算输出误差"></a>计算输出误差</h2><p>  根据实际输出和实际期望输出(测试集)，来定义损失函数。网络的输出误差就是通过这个损失函数（如均方误差或交叉熵损失）来计算的。</p><h2 id="反向传播误差"><a href="#反向传播误差" class="headerlink" title="反向传播误差"></a>反向传播误差</h2><p>  由输出层各节点的误差和激活函数(激活函数定义了各个节点的输出如何从上一层加权输入计算得到)反向计算中间隐含节点的误差。这个过程体现了每个节点对最终损失的间接影响。</p><h2 id="计算梯度"><a href="#计算梯度" class="headerlink" title="计算梯度"></a>计算梯度</h2><p>  隐含节点的梯度是根据网络中每条边的权重(该权重是由该边所连通的两个节点的误差计算的)以及其激活函数的导数。为了计算损失函数相对于特定权重的导数，需要用到链式法则，链式法则允许我们将损失函数的导数分解为多个相对简单函数的导数的乘积其中包括了节点的激活函数的导数。<br>  接下来要做的工作就是迭代(可以理解成多次执行反向传播算法)，使各个节点的梯度下降，得到最优的参数。当然这是从调节参数使网络顺利地拟合我们训练数据的曲线，当然要考虑过拟合的情况，如果出现了过拟合，那么这种人为的刻意适合就完全没有推广价值。下篇博客再详细说明～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  反向传播算法可以调整人工神经网络中出问题的“组件”，降低神经网络预测或者分类的错误率，提高模型的准确率，从而提高效率。那么反向传播算法是如何发挥作用的呢？&lt;br&gt;  对于每个神经网络来说，都有输入神经元与输出神经元，输入神经元到输出神经元的映射可以描述为一个函数，这个函</summary>
      
    
    
    
    
    <category term="Pytorch" scheme="http://example.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>三重大脑理论---《认知觉醒》读后感1</title>
    <link href="http://example.com/2024/02/28/%E4%B8%89%E9%87%8D%E5%A4%A7%E8%84%91%E7%90%86%E8%AE%BA-%E3%80%8A%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F1/"/>
    <id>http://example.com/2024/02/28/%E4%B8%89%E9%87%8D%E5%A4%A7%E8%84%91%E7%90%86%E8%AE%BA-%E3%80%8A%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F1/</id>
    <published>2024-02-28T15:04:20.000Z</published>
    <updated>2024-03-08T06:22:41.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重新认识你的大脑"><a href="#重新认识你的大脑" class="headerlink" title="重新认识你的大脑"></a>重新认识你的大脑</h1><p>  我猜很多人并不真正了解自己，甚至从未了解过，所以才会对自身的各种问题困惑不已。这里我说的“自己”，特指自己的大脑部分，因为没有大脑，我们什么都不是；有大脑，但不了解它，我们就只能凭模糊的感觉生活，而那样的生活通常不是我们想要的。<br>  从大脑开始，重新认识自己，我们会再“进化”一次。</p><h1 id="三重大脑"><a href="#三重大脑" class="headerlink" title="三重大脑"></a>三重大脑</h1><p>  人类能成为这个星球上最高等的生物，完全仰仗那智慧的大脑。在人们眼中，它精密无比，堪称完美，科学技术发展至今也无法完全解开它的秘密。然而事实证明它并不完美，甚至问题重重，这些问题也正是让我们感到无能和痛苦的根源。要想了解这一点，我们需要先了解大脑的进化历程。<br>起初，地球上并没有生命。但在数十亿年前，远古的海洋中出现了一些“复制子”，在进化的力量下，它们逐渐成为单细胞生物，接着又演化为动物、植物和微生物等，之后动物这条分支进化成各种原始鱼类，遍布大海。<br>  约3.6亿年前，它们开始向陆地进军，地球进入属于爬行动物的时代。为了适应陆地生活，爬行动物演化出了最初的“本能脑”。本能脑的结构很简单，只有一个原始的反射模块，可以让爬行动物对环境快速做出本能反应，比如遇到危险就战斗或逃跑，遇到猎物就捕食，遇到心仪的异性就追求等。爬行动物既没有情感也没有理智，体温随外界变化的特性也让它们无法在寒冷的环境中活动，但依靠这种简单的本能反应，它们不仅生存了下来，一些动物还活到了我们这个时代，比如鳄鱼、蜥蜴、蛇等。所以很多学者把本能脑也称为原始脑、基础脑、鳄鱼脑、蜥蜴脑，或者干脆叫爬行脑。<br>  到了大约2亿年前，哺乳动物开始登场。它们为了更好地适应环境，不仅让体温保持恒定，还进化出了情绪。有了情绪的加持，哺乳动物就能在恶劣的环境中趋利避害，大大提升了其生存优势，比如恐惧情绪可以让自己远离危险，兴奋情绪可以让自己专注捕猎，愉悦情绪可以增强同伴间的亲密度，伤心情绪能引来同情者的关爱等。这也是为什么我们喜欢把猫或狗当成宠物，因为这些动物很容易和我们产生情感上的交流，懂得取悦和照顾我们。相应的，哺乳动物的大脑里也发展出一个独特的情感区域（边缘系统），脑科学家称之为“情绪脑”。在哺乳动物中，猴子经常被人类当作观察和实验的对象，因此情绪脑通常也被称作猴子脑。<br>  直到距今约250万年前，人类才从哺乳动物中脱颖而出，在大脑的前额区域进化出了“新皮层”。这个新皮层直到7万~20万年前才真正成形，成为一个无与伦比的脑区，它让我们产生语言、创造艺术、发展科技、建立文明，从此在这个星球上占据了绝对的生存优势。人类沉迷于自己独有的理智，所以把这个新的脑区称为“理智脑”，当然，也有人喜欢称它为理性脑或思考脑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重新认识你的大脑&quot;&gt;&lt;a href=&quot;#重新认识你的大脑&quot; class=&quot;headerlink&quot; title=&quot;重新认识你的大脑&quot;&gt;&lt;/a&gt;重新认识你的大脑&lt;/h1&gt;&lt;p&gt;  我猜很多人并不真正了解自己，甚至从未了解过，所以才会对自身的各种问题困惑不已。这里我说的</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>搜索引擎项目实战</title>
    <link href="http://example.com/2024/02/23/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    <id>http://example.com/2024/02/23/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</id>
    <published>2024-02-22T16:52:06.000Z</published>
    <updated>2024-03-27T06:07:37.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建服务端框架"><a href="#搭建服务端框架" class="headerlink" title="搭建服务端框架"></a>搭建服务端框架</h1><p>服务器的搭建，采用封装好的TcpServer (下篇博客再说明)，然后等待客户端的连接，接收客户端的查询请求。</p><h1 id="关键字推荐部分"><a href="#关键字推荐部分" class="headerlink" title="关键字推荐部分"></a>关键字推荐部分</h1><h2 id="获取到客户端传递过来的查询词之后，再从索引之中查找与之相近的候选词，选取到最合适的候选词之后再将其发送给客户端。"><a href="#获取到客户端传递过来的查询词之后，再从索引之中查找与之相近的候选词，选取到最合适的候选词之后再将其发送给客户端。" class="headerlink" title="获取到客户端传递过来的查询词之后，再从索引之中查找与之相近的候选词，选取到最合适的候选词之后再将其发送给客户端。"></a>获取到客户端传递过来的查询词之后，再从索引之中查找与之相近的候选词，选取到最合适的候选词之后再将其发送给客户端。</h2><p>候选词的选取包括以下几个部分：</p><ol><li>实现最小编辑距离核心算法来计算候选词与查询词的相似度；</li><li>候选词选择策略：hello helli；</li><li>获取k 个（例如3 个或者5 个）候选词，返回给客户端。（需要使用优先级队列）</li></ol><ul><li>优先比较最小编辑距离；</li><li>在编辑距离相同的条件下，再比较候选词的词频；词频越大优先选择；</li><li>在词频相同的条件下，按字母表顺序比较候选词；</li></ul><h2 id="发送给客户端的数据要采用JSON-数据格式封包。对于Json-开源库的选择，"><a href="#发送给客户端的数据要采用JSON-数据格式封包。对于Json-开源库的选择，" class="headerlink" title="发送给客户端的数据要采用JSON 数据格式封包。对于Json 开源库的选择，"></a>发送给客户端的数据要采用JSON 数据格式封包。对于Json 开源库的选择，</h2><p>可以有多种，比如jsoncpp、或者nlohmann&#x2F;json[位于github 上]，建议用后者，比前者好用。</p><h2 id="功能优化：引入缓存系统"><a href="#功能优化：引入缓存系统" class="headerlink" title="功能优化：引入缓存系统"></a>功能优化：引入缓存系统</h2><p>设计思路：</p><ul><li>根据线程池中工作线程的数量，每一个工作线程对应一个缓存。</li><li>每个缓存内部采用LRU 算法对冷数据进行淘汰。</li><li>当工作一段时间后，每个缓存的内容会不一致，因此需要更新缓存。</li><li>更新缓存的操作，交给一个定时器完成，每隔固定的时间，更新缓存数据。</li></ul><h2 id="处理中文语料"><a href="#处理中文语料" class="headerlink" title="处理中文语料"></a>处理中文语料</h2><p>设计思路：</p><ul><li>首先需要对中文进行分词，然后再去统计每个词语的词频，建立中文词典和索引，类似英文的处理。</li><li>对中文进行分词，需要使用开源的分词库，如cppjieba, NLPIR，所以要了解分词库的用法。推荐使用cppjieba.</li><li>扩展最小编辑距离算法，让其能对中文进行处理。</li></ul><h1 id="网页推荐部分"><a href="#网页推荐部分" class="headerlink" title="网页推荐部分"></a>网页推荐部分</h1><h2 id="建立网页库和网页偏移库"><a href="#建立网页库和网页偏移库" class="headerlink" title="建立网页库和网页偏移库"></a>建立网页库和网页偏移库</h2><h3 id="网页库的格式采用xml-的形式，像rss文件一样"><a href="#网页库的格式采用xml-的形式，像rss文件一样" class="headerlink" title="网页库的格式采用xml 的形式，像rss文件一样"></a>网页库的格式采用xml 的形式，像rss文件一样</h3><h3 id="将所给语料库中的所有文档按照格式，构造成网页库ripepage-dat"><a href="#将所给语料库中的所有文档按照格式，构造成网页库ripepage-dat" class="headerlink" title="将所给语料库中的所有文档按照格式，构造成网页库ripepage.dat"></a>将所给语料库中的所有文档按照格式，构造成网页库ripepage.dat</h3><p>提取网页的标题的策略如下：</p><ul><li>如果查找到字符串“标题”，则抽取该行的内容为标题；</li><li>如果没有找到，则提取文档的第一行为标题；<br>整个文档的全部内容为content（包括标题）Url 使用每篇文档所在的绝对路径；然后将所有的字符串拼接起来，构成一篇格式化的文档。</li></ul><h3 id="获取格式化好的文档之后，通过C-的文件输出流将文档写到文件中去，同时记录下该篇文档在文件的位置信息，即offset-dat。"><a href="#获取格式化好的文档之后，通过C-的文件输出流将文档写到文件中去，同时记录下该篇文档在文件的位置信息，即offset-dat。" class="headerlink" title="获取格式化好的文档之后，通过C++的文件输出流将文档写到文件中去，同时记录下该篇文档在文件的位置信息，即offset.dat。"></a>获取格式化好的文档之后，通过C++的文件输出流将文档写到文件中去，同时记录下该篇文档在文件的位置信息，即offset.dat。</h3><h2 id="网页去重"><a href="#网页去重" class="headerlink" title="网页去重"></a>网页去重</h2><p>采用google开源的Simhash算法对网页库进行去重。</p><h2 id="建立倒排索引库"><a href="#建立倒排索引库" class="headerlink" title="建立倒排索引库"></a>建立倒排索引库</h2><p>倒排索引是指一个未经处理的网页库中，一般是以文档ID 作为索引，以文档内容作为记录。而Inverted index 指的是将单词或记录作为索引，将文档ID 作为记录，这样便可以方便地通过单词或记录查找到其所在的文档。</p><p>在此项目中，倒排索引的数据结构采用的是:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map &lt;string, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&gt;&gt; InvertIndexTable</span><br></pre></td></tr></table></figure><p>其中unorderedmap的key 为出现在文档中的某个词语，对应的value 为包含该词语的文档ID 的集合以及该词语的权重值w</p><p><strong>而建立倒排索引最难的点就在于每个词语的权重值w的计算</strong>，这里采用TF-IDF标准来计算每个词语的权重值w：<br>TF： 某个词在文章中出现的次数；<br>DF： 某个词在所有文章中出现的次数，即包含该词语的文档数量；<br>IDF: 逆文档频率，表示该词对于该篇文章的重要性的一个系数，其计算公式为：<br>IDF &#x3D; log2(N&#x2F;(DF+1))<br>其中N 表示文档的总数或网页库的文档数<br>最后，词语的权重w 则为：<br>w &#x3D; TF * IDF<br>可以看到权重系数与一个词在文档中的出现次数成正比，与该词在整个网页库中的出现次数成反比。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搭建服务端框架&quot;&gt;&lt;a href=&quot;#搭建服务端框架&quot; class=&quot;headerlink&quot; title=&quot;搭建服务端框架&quot;&gt;&lt;/a&gt;搭建服务端框架&lt;/h1&gt;&lt;p&gt;服务器的搭建，采用封装好的TcpServer (下篇博客再说明)，然后等待客户端的连接，接收客户端的</summary>
      
    
    
    
    
    <category term="C++  Linux开发" scheme="http://example.com/tags/C-Linux%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深度学习实战</title>
    <link href="http://example.com/2024/02/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/"/>
    <id>http://example.com/2024/02/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/</id>
    <published>2024-02-22T16:45:47.000Z</published>
    <updated>2024-03-08T06:47:12.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深度学习与人工智能"><a href="#深度学习与人工智能" class="headerlink" title="深度学习与人工智能"></a>深度学习与人工智能</h2><p>   什么是深度学习？深度学习是一个基于深度人工神经网络的使计算机可以自己学习、分类和预测的技术。本质来说，深度学习就是人工神经网络。<br>   人工智能的覆盖面非常广，包括自动推理、联想、学习等。机器学习则是人工智能的一个重要分支，在众多机器学习算法中，深度学习算法杀出重围，逐渐占据高位，原因是深度学习中的反向传播算法可以有效调节深度人工神经网络中出现问题组件，从而降低网络分类或预测的错误率，规避大量无效的学习，提高效率。</p><h2 id="深度学习的影响因素"><a href="#深度学习的影响因素" class="headerlink" title="深度学习的影响因素"></a>深度学习的影响因素</h2><p>   深度学习有三大影响因素，分别是：大数据、深度学习架构与GPU，这三者本质上说的是数据、算法与算力。</p><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><p>   深度神经网络并不算新技术，早在20世纪八九十年代，人们就提出了增加神经网络的深度以获得更高准确度的设想，但是由于当时硬件发展速度跟不上，人们很难实现深度的神经网络。当然，更主要的原因是当时根本没有足够的大规模数据输入给深度神经网络，因此自然也就无法发挥深度的作用。伴随着网络深度的增加，待拟合的参数自然也会增加，如果没有与其相匹配的海量数据来训练网络，这些参数就完全变成了导致网络过拟合的垃圾，无法发挥作用。<br>   然而，到了21世纪的第二个十年，一切都不一样了。有数据显示，2014年，整个互联网上每秒钟就有60万条信息在Facebook上分享，2亿封邮件、10万条推文发出，571个新网站被建立，1.9E字节的数据被交换[插图]。随着互联网特别是移动互联网时代的到来，我们每一个动作都会被网络服务器记录下来，这些数据促使人类一下子进入了大数据时代。<br>   大数据时代的到来为深度神经网络的大规模应用铺平了道路，加深网络获得更高精度的设想终于在海量数据的基础上得以验证。<br>   <img src="/assets/%E5%A4%A7%E6%95%B0%E6%8D%AE.png" alt="数据规模对于网络预测准确度的影响"></p><h3 id="深度学习架构"><a href="#深度学习架构" class="headerlink" title="深度学习架构"></a>深度学习架构</h3><p>  认为当下深度学习技术革命的发展完全是拜大数据所赐，只要有足够规模的数据，随便调试一个模型就能得到很好的预测效果，这种观点是非常片面的。<br>  当面对一个具体问题时，应该采用什么样的网络架构，如何选取超参数，如何训练这个网络，仍然是影响学习效率和问题解决的重要因素。<br>  所谓的深度网络架构，就是整个网络体系的构建方式和拓扑连接结构，目前主要分为3种：前馈神经网络、卷积神经网络和循环神经网络。</p><h4 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h4><p>   前馈神经网络也叫全连接网络(fully connected neural network)。在这种结构中，所有的节点都可以分为一层一层的，每个节点只跟它的相邻层节点而且是全部节点相连（也就是全连接的）。这些层一般分为输入层、输出层以及介于二者之间的隐含层。这种前馈神经网络是目前应用最多的一类神经网络。<br>   <img src="/assets/%E5%89%8D%E9%A6%88.png" alt="前馈神经网络"></p><h4 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h4><p>   另一种常见的神经网络就是卷积神经网络(CNN)图中每一个立方体都是一系列规则排列的人工神经元集合。每个神经元到上一层次的连接称为卷积核，这是一种局域的小窗口。图中的小锥体可以理解为从高层的某一个神经元到低层多个神经元之间的连接。这个小锥体在立方体上逐像素的平移就构成了两层次之间的所有连接。到了最后两层，小立方体被压缩成了一个一维的向量，这就与普通的前馈神经网络没有任何区别了。CNN这种特殊的架构可以很好地应用于图像处理，它可以使原始图像即使经历平移、缩放等变换之后仍然具有很高的可识别性。正是因为具有这样特殊的架构，CNN才成功应用于计算机视觉、图像识别、图像生成，甚至AI下围棋、AI打游戏等广阔的领域。<br>   <img src="/assets/%E5%8D%B7%E7%A7%AF.png" alt="卷积神经网络"></p><h4 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h4><p>   还有一种常见的网络架构，就是被广泛应用于自然语言处理任务中的循环神经网络(RNN),如图所示：<br>   <img src="/assets/RNN.png" alt="RNN"><br>   图的左侧为输入节点，右侧为输出节点，中间的隐含层节点互相连接。可以看到，这种网络与普通的三层前馈神经网络非常相似，只不过隐含层彼此之间还具有大量的连接。RNN这种特殊架构使得网络当前的运行不仅跟当前的输入数据有关，还与之前的数据有关。因此，这种网络特别适合处理诸如语言、音乐、股票曲线等序列类型的数据。整个网络的循环结构可以很好地应付输入序列之中存在的长程记忆性和周期性。<br>   除了架构会影响深度网络的表现以外，训练方式也会对结果产生很大的影响。有两篇文章可以说明训练方式的重要性。第一篇文章是约书亚·本吉奥(Yoshua Bengio)的《课程学习》(“Curriculum Learning”)，该文章指出当我们用数据训练人工神经网络时，不同的顺序会对网络学习速度和最终表现产生重要影响。我们如果先将少量特定标签的数据输入网络，然后拿剩下的数据去训练它，就会比一股脑儿地把所有标签的数据都输入给它要更加有效，从而提高网络的“学习”能力。这就像人类学习一样，有步骤地学习会比一股脑儿地记下所有的知识更好。该学习方式将帮助机器学习吸取人类学习的优点，提升学习效果，协助其跳出局部极优，提高泛化能力。第二篇文章是《在深度神经网络中特征是如何变成可迁移的》(“How Transferable are Features in Deep Neural Network?”)，该文章详细比较了不同的训练方式如何影响网络的学习效率。有了更有效的学习，我们就可以通过迁移学习将训练好的神经网络迁移到新的小数据集中，从而达到很好的表现。<br>   AlphaGo的复杂训练流程也向我们展示了训练方式和训练路径对于一个深度学习系统的重要性。首先，AlphaGo团队根据人类的下棋经验快速训练了一个小的网络——快速走棋网络，在此基础上，再根据人类下棋的棋谱训练一个大的网络——监督学习走棋网络；然后，在这个网络的基础上，让AlphaGo通过和自己下棋得到一个强化学习走棋网络；最后，在此基础上得到价值网络。整个训练流程非常复杂却又十分精巧，包含了无数训练技巧。</p><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>   影响深度学习性能的最后一个因素是GPU。GPU就是图形处理单元(graphics processing unit)，和CPU一样，都是做计算的基本单元，GPU最主要的功能是可以进行张量计算，什么是张量？张量可以理解为多维数组(我们常见的是二维数组，即矩阵)，GPU的矩阵运算并行化可以帮助我们快速实现对神经网络的训练，因为训练的运算过程可以全部转化成高阶矩阵（多维数组，张量）的运算过程，而这正是GPU所擅长的。有了GPU，我们就可以在一个可接受的时间内训练好神经网络。</p><h2 id="深度学习为何如此成功？"><a href="#深度学习为何如此成功？" class="headerlink" title="深度学习为何如此成功？"></a>深度学习为何如此成功？</h2><p>   要回答这个问题，就要了解深度学习的本质特色，那就是对所学特征的“表达能力”(representation)。换句话说，深度学习重要的本领在于它可以从海量的数据中自动学习，抽取数据中的特征。</p><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>   深度神经网络的一个特性是会把不同的信息表达到不同层次的网络单元（权重）之中，并且这一提炼过程完全不需要手动干预，全凭机器学习过程自动完成，这就是我们常说的特征学习(feature learning)。深度学习的本质就是这种自动提取特征的功能。</p><h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><p>   除此之外，深度神经网络的另一个重要特性就在于特征提取之后的迁移学习(transfer learning)。我们可以像做脑外科手术一样把一个训练好的神经网络切开，然后再把它拼合到另一个神经网络上。正如我们刚才所说的，神经网络可以在各个层编码表示数据中不同尺度的特征。也就是说，前几层神经网络就好像一个特征提取器，作用就是提炼特征，而后面部分的网络会根据这些特征进行分类或者预测。当把神经网络组合拼接之后，我们就可以用前面部分的神经网络进行特征提取，再将这个特征提取器与后面的网络进行拼接，去解决另一个完全不同的问题，这就叫迁移学习。 </p><h2 id="Pytorch简介"><a href="#Pytorch简介" class="headerlink" title="Pytorch简介"></a>Pytorch简介</h2><p>   Pytorch具备三个最关键的特性，使其与深度学习完美结合，分别是：与Python完美融合、支持张量计算、动态计算图。<br>   其中，与Python完美融合是指在Pytorch框架下，写代码就像写python代码一样，用户丝毫感受不到使用Python和PyTorch的区别。前面提到GPU是影响深度学习的关键因素之一，GPU最大的功能就是进行张量并行计算，而pytorch下面的库可以原子化的进行张量计算，不需要用户编程去进行张量计算。最后Pytorch可以动态构建计算图。<br>   人工神经网络之所以在诸多机器学习算法中脱颖而出，就是因为它可以利用反向传播算法来更新内在的计算单元，从而更加精准地解决问题。反向传播算法能够精确地计算出网络中每一个单元对于网络表现的贡献（即所谓的梯度信息），利用这种技术大大提高了神经网络的训练效率，从而避免了大量无效学习。<br>   在深度学习框架出现之前，针对不同的神经网络架构，需要编写不同的反向传播算法，这就增加了难度和工作量。而现在的深度学习框架引用了计算图技术，计算图技术就是在训练神经网络的过程中保存每个节点计算的结果和每个节点的路径，从而构建出一种描述和记录张量运算过程的抽象网络。如图所示：<br>   <img src="/assets/%E8%AE%A1%E7%AE%97%E5%9B%BE.png" alt="计算图"><br>   计算图的出现给反向传播算法提供了一个基础图，此时人们只需要关注神经网络的前馈计算，再计算每个节点的梯度信息，经过多次迭代调整参数，使该神经网络的预测或分类效果达到最优即可。而PyTorch既可以动态地构建计算图，又可以同时在计算图上执行计算，执行完计算后还可以继续构建计算图，而不必将构建计算图和图上的计算过程分离。这样一来，PyTorch构造计算图的过程就像写普通的Python语句一样方便、快捷，而且，这种动态计算图技术也让代码的调试和追踪更加简便。<br>   PyTorch是借助自动微分变量(autograd variable)来实现动态计算图的。从表面上看，自动微分变量与普通的张量没有什么区别，都可以进行各种运算，但是它的内部数据结构比张量更复杂。在采用自动微分变量以后，无论一个计算过程多么复杂，系统都会自动构造一个计算图来记录所有的运算过程。在构建好动态计算图之后，我们就可以非常方便地利用.backward()函数自动执行反向传播算法，从而计算每一个自动微分变量的梯度信息。它是怎么做到的呢？自动微分变量是通过3个重要的属性data、grad以及grad_fn来实现的。data是一个伴随着自动微分变量的张量，专门存储计算结果。我们平时可以将自动微分变量当成普通的张量来使用，几乎没有什么区别。这样，PyTorch会将计算的结果张量存储到自动微分变量的data分量里面。此外，当采用自动微分变量进行运算的时候，系统会自动构建计算图，也就是存储计算的路径。因此，我们可以通过访问一个自动微分变量的grad_fn（旧版本是creator）来获得计算图中的上一个节点，从而知道是哪个运算导致现在这个自动微分变量的出现。所以，每个节点的grad_fn其实就是计算图中的箭头。我们完全可以利用grad_fn来回溯每一个箭头，从而重构出整个计算图。最后，当执行反向传播算法的时候，我们需要计算计算图中每一个变量节点的梯度值（gradient，即该变量需要调整的增量）。我们只需要调用.backward()这个函数，就可以计算所有变量的梯度信息，并将叶节点的导数值存储在.grad中(非叶节点无梯度值，因为非叶节点大多是计算中间变量，只为了方便人类阅读，而不会影响计算，因此也不需要计算梯度信息)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;深度学习与人工智能&quot;&gt;&lt;a href=&quot;#深度学习与人工智能&quot; class=&quot;headerlink&quot; title=&quot;深度学习与人工智能&quot;&gt;&lt;/a&gt;深度学习与人工智能&lt;/h2&gt;&lt;p&gt;   什么是深度学习？深度学习是一个基于深度人工神经网络的使计算机可以自己学习、分类</summary>
      
    
    
    
    
    <category term="Jupyter_notebook Pytorch" scheme="http://example.com/tags/Jupyter-notebook-Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="http://example.com/2024/02/08/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/02/08/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-08T11:59:27.000Z</published>
    <updated>2024-04-21T07:19:39.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git的应用场景"><a href="#git的应用场景" class="headerlink" title="git的应用场景"></a>git的应用场景</h2><p>git的应用于程序员进行项目合作时作为版本控制器。</p><h2 id="git的安装与配置"><a href="#git的安装与配置" class="headerlink" title="git的安装与配置"></a>git的安装与配置</h2><p>在Linux系统中，打开终端，输入如下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>安装完成之后，运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git</span><br></pre></td></tr></table></figure><p><img src="/assets/git%E5%AE%89%E8%A3%85.png" alt="git安装"></p><h2 id="创建一个版本库"><a href="#创建一个版本库" class="headerlink" title="创建一个版本库"></a>创建一个版本库</h2><p>新建一个目录gtest，在gtest目录下创建一个版本库，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><img src="/assets/git%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93.png" alt="git创建版本库01"><br>可以看到在gtest目录下创建了一个.git隐藏目录，这就是版本库目录。</p><h3 id="版本的创建与回退"><a href="#版本的创建与回退" class="headerlink" title="版本的创建与回退"></a>版本的创建与回退</h3><p>在gtest目录下创建一个文件code.txt，并且用如下两条命令创建一个版本库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add code.txt</span><br><span class="line">git commit -m <span class="string">&#x27;版本1&#x27;</span></span><br></pre></td></tr></table></figure><p>编辑内容如下：<br><img src="/assets/git03.png" alt="git创建版本库02"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git的应用场景&quot;&gt;&lt;a href=&quot;#git的应用场景&quot; class=&quot;headerlink&quot; title=&quot;git的应用场景&quot;&gt;&lt;/a&gt;git的应用场景&lt;/h2&gt;&lt;p&gt;git的应用于程序员进行项目合作时作为版本控制器。&lt;/p&gt;
&lt;h2 id=&quot;git的安装与配</summary>
      
    
    
    
    
  </entry>
  
</feed>
